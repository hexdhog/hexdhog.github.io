<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Bare blinky | hexdhog</title>
<meta name=keywords content><meta name=description content="I have messed with electronics for quite some time now, pretty much ever since I started programming. Actually, I learned basic C programming by playing in Arduino IDE. So I have a decent understanding of how to write basic programs that run on Arduino-like compatible microcontrollers; but I have a mediocre understanding of what is actually going on when I use the Arduino or, even, the chip&rsquo;s framework. So I want to go down the software stack and understand exactly what really happens under the hood. I think making an LED blink, an extremely basic task, in assembly and without any libraries/frameworks is a decent starting point."><meta name=author content><link rel=canonical href=https://hexdhog.com/posts/bare-blinky/><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://hexdhog.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://hexdhog.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://hexdhog.com/favicon-32x32.png><link rel=apple-touch-icon href=https://hexdhog.com/apple-touch-icon.png><link rel=mask-icon href=https://hexdhog.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://hexdhog.com/posts/bare-blinky/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous referrerpolicy=no-referrer><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous referrerpolicy=no-referrer type=text/javascript></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous referrerpolicy=no-referrer type=text/javascript></script><script type=text/javascript>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})})</script><meta property="og:url" content="https://hexdhog.com/posts/bare-blinky/"><meta property="og:site_name" content="hexdhog"><meta property="og:title" content="Bare blinky"><meta property="og:description" content="I have messed with electronics for quite some time now, pretty much ever since I started programming. Actually, I learned basic C programming by playing in Arduino IDE. So I have a decent understanding of how to write basic programs that run on Arduino-like compatible microcontrollers; but I have a mediocre understanding of what is actually going on when I use the Arduino or, even, the chip’s framework. So I want to go down the software stack and understand exactly what really happens under the hood. I think making an LED blink, an extremely basic task, in assembly and without any libraries/frameworks is a decent starting point."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-27T00:00:00+00:00"><meta property="article:modified_time" content="2025-02-27T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Bare blinky"><meta name=twitter:description content="I have messed with electronics for quite some time now, pretty much ever since I started programming. Actually, I learned basic C programming by playing in Arduino IDE. So I have a decent understanding of how to write basic programs that run on Arduino-like compatible microcontrollers; but I have a mediocre understanding of what is actually going on when I use the Arduino or, even, the chip&rsquo;s framework. So I want to go down the software stack and understand exactly what really happens under the hood. I think making an LED blink, an extremely basic task, in assembly and without any libraries/frameworks is a decent starting point."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://hexdhog.com/posts/"},{"@type":"ListItem","position":2,"name":"Bare blinky","item":"https://hexdhog.com/posts/bare-blinky/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Bare blinky","name":"Bare blinky","description":"I have messed with electronics for quite some time now, pretty much ever since I started programming. Actually, I learned basic C programming by playing in Arduino IDE. So I have a decent understanding of how to write basic programs that run on Arduino-like compatible microcontrollers; but I have a mediocre understanding of what is actually going on when I use the Arduino or, even, the chip\u0026rsquo;s framework. So I want to go down the software stack and understand exactly what really happens under the hood. I think making an LED blink, an extremely basic task, in assembly and without any libraries/frameworks is a decent starting point.\n","keywords":[],"articleBody":"I have messed with electronics for quite some time now, pretty much ever since I started programming. Actually, I learned basic C programming by playing in Arduino IDE. So I have a decent understanding of how to write basic programs that run on Arduino-like compatible microcontrollers; but I have a mediocre understanding of what is actually going on when I use the Arduino or, even, the chip’s framework. So I want to go down the software stack and understand exactly what really happens under the hood. I think making an LED blink, an extremely basic task, in assembly and without any libraries/frameworks is a decent starting point.\nSetup I bought a CH32V003 kit a while back with this goal in mind.\nIt’s a microcontroller based on QuingKe RISC-V2A with 2KB SRAM, 16KB FLASH, PFIC and comes with a bunch of very common peripherals (e.g. I2C, USART, SPI, ADC, etc). The kit also includes a WCH-LinkE, a USB to SWIO bridge, which is used to program the microcontroller and monitor the USART interface.\nI am using PlatformIO to manage the project, although that isn’t really relevant to this post.\nPlan The CH32V003 kit’s PCB has an LED connected to GPIO D4 which emits light when that pin is low. So we need a way to manipulate the GPIO pin. Then we need a way to time the actions perfomed on the GPIO pin, so that the LED actually blinks and it does so at a constant rate.\nThe following block diagram depicts the CH32V003 system architecture:\nThere are three GPIO ports: GPIOA (PA1-PA2), GPIOC (PC0-PC7) and GPIOD (PD0-PD7) which are completely seperate GPIO controllers. Like most peripherals, they are accessed through the AHB bus. Each of these peripheral controllers has a set of registers that control the behaviour of the actual peripheral, and each of these registers is wired to the bus. Additionally, although not specified in the block diagram, the CH32V003 core has a system tick counter which we can use to time the GPIO actions. Like the peripherals on the AHB bus, it has a set of registers that control its behaviour.\nThis is what’s called Memory Mapped IO, and it is very common in microcontrollers. The registers from the peripheral controllers are each assigned a unique memory address. Therefore, interfacing with each register translates to a read and/or write operation from/to the bus. The CH32V003 has the following memory map:\nNote that FLASH and SRAM are also peripherals and, while they are connected on different buses, are accesed in the same way as any other peripheral. This means that all components are wired in a way such that when the RISC-V2A core selects an address to read/write to, the correct bus and peripheral controller register is enabled and given access to the bus. So to us, the RISC-V2A core programmers, accessing any peripheral is analogous to reading/writing data to memory.\nAccording to the memory map diagram, the GPIO port D registers are located between addresses 0x40011400 and 0x40011800, and, though not specified, the system tick timer’s registers are located in the Core Private Peripherals section (0xe000000 to 0xe0100000).\nSystem clock setup Before setting anything else up we should initialize the system clock. After reset, the CH32V003 uses the HSI (High Speed Internal) oscillator at 24MHz as a clock source. The PLL (Phase Locked Loop), used to multiply the input clock source, is disabled. An HSE (High Speed Extenal) oscillator 4-25MHz can also be used as a clock source which is disabled after reset; up to de user to set it up on every startup.\nThe following block diagram shows the system clock tree:\nA few important notes about the clock tree that we should care about:\nHSE and HSI can multiplied by 2 through a PLL, so SYSCLK output is multiplexed between HSI, HSE, HSI*2 and HSE*2 HCLK is prescaled (divisible by: 1, 2, …, 256) from SYSCLK HCLK is used for HB peripherals (GPIO) HCLK is used for Core System Timer and can be divided by 8 (useful for longer timer delays) Because HCLK depends on SYSCLK, let’s configure SYSCLK first. We’ll configure it at 48MHz; the maximum supported frequency. Because we don’t have an external crystal (HSE), we’ll use the internal oscillator (HSI) which runs at 24MHz and feed it to the PLL to multiply it by 2 (24MHz * 2 = 48MHz). So first of all, we have to enable both HSI and PLL and configure HSI as PLL source. Then, because we’ll need to kwow when PLL is ready before we can actually select it as a clock source, we should clear RCC interrupt flags. These flags indicate the state of different clock devices and are used to detect when different events happen, and PLL being ready is one of them. Because these flags don’t auto-reset we have to reset them so that we can detect when PLL is ready. The next obvious step to finish SYSCLK configuration would be to select HSI+PLL (HSI*2) by selecting PLL as clock source, but before we do that we should configure everything that depends on SYSCLK so that when we do enable it everything else is setup and ready to go. For our use case there are two things to configure: HCLK prescaler configuration (we want to turn it off so that HCLK = SYSCLK = 48MHz) and flash with a 1 cycle latency (this is recommended in the reference manual when 24MHz \u003c= SYSCLK \u003c= 48MHz). The last thing to do is to wait for the PLL to be ready, select it as SYSCLK source and wait until it is actually used as SYSCLK before executing the rest of the program.\nBecause some of the steps detailed above can be perfomed at the same time we can optimise the list of steps to look like this:\nEnable HSI and PLL Select HSI as PLL source and turn off prescaler Clear RCC interrupt flags Configure flash to use 1 cycle latency Wait until PLL is ready Select PLL as SYSCLK Wait until PLL is used as SYSCLK All of these steps are performed using the RCC (Reset and Clock Control) registers, with base address 0x40021000:\nand the FLASH registers, with base address 0x40022000:\nMore specifically, we’ll need the following registers:\nR32_RCC_CTLR R32_RCC_CFGR0 R32_RCC_INTR R32_FLASH_ACTLR Note: the description of each field for all registers is left out for brevity. More information can be found in the reference manual.\nEnable HSI and PLL HSI and PLL are enabled through R32_RCC_CTLR field HSION (bit 0) and field PLLON (bit 24). For both fields, writing a 1 will enable the device and writing a 0 will disable it. So let’s write some RISC-V assembly code that enables them both:\n.equ rcc_base, 0x40021000 .equ flash_r_base, 0x40022000 .equ gpio_pd_base, 0x40011400 .equ systck_base, 0xe000f000 .equ led_pin, 4 .globl main main: li a0, rcc_base # a0 -\u003e RCC register base address li a1, flash_r_base # a1 -\u003e FLASH register base address li a2, gpio_pd_base # a2 -\u003e GPIO port d register base address # PLL_ON (bit 0): enable PLL # HSI_ON (bit 24): enable HSI # RCC CTLR = 1 \u003c\u003c 0 | 1 \u003c\u003c 24 # RCC CTLR = 0x01000001 li t0, 0x01000001 sw t0, 0(a0) li a0, rcc_base # a0 -\u003e RCC register base address li a1, flash_r_base # a1 -\u003e FLASH register base address li a2, gpio_pd_base # a2 -\u003e GPIO port d register base address # PLL_ON (bit 0): enable PLL # HSI_ON (bit 24): enable HSI # RCC CTLR = 1 \u003c\u003c 0 | 1 \u003c\u003c 24 # RCC CTLR = 0x01000001 li t0, 0x01000001 sw t0, 0(a0) Note: a few lines of code have been added, like constant definitions, which will be needed later.\nSelect HSI as PLL source and turn off prescaler The prescaler is turned off by writing 0 to R32_RCC_CFGR0 field HPRE (bits 4-7) and HSI is selected as PLL source by writing 0 to field PLLSRC (bit 16):\n# HPRE = 0: prescaler off; do not divide SYSCLK # PLLSRC = 0: HSI (instead of HSE) for PLL input # RCC_CFGR0 = 0 \u003c\u003c 4 | 0 \u003c\u003c 16 # RCC_CFGR0 = 0 li t0, 0x00000000 sw t0, 4(a0) Clear RCC interrupt flags Clearing the RCC interrupt flags, actually involves all R32_RCC_INTR fields, so let’s take a closer look at them to better understand how this register works:\nbit name access description 0 LSIRDYF RO LSI clock-ready interrupt flag 2 HSIRDYF RO HSI clock-ready interrupt flag 3 HSERDYF RO HSE clock-ready interrupt flag 4 PLLRDYF RO PLL clock-ready lockout interrupt flag 7 CSSF RO Clock security system interrupt flag bit 8 LSIRDYIE RW LSI-ready interrupt enable bit 10 HSIRDYIE RW HSI-ready interrupt enable bit 11 HSERDYIE RW HSE-ready interrupt enable bit 12 PLLRDYIE RW PLL-ready interrupt enable bit 16 LSIRDYC WO Clear the LSI oscillator ready interrupt flag bit 19 HSERDYC WO Clear the HSE oscillator ready interrupt flag bit 18 HSIRDYC WO Clear the HSI oscillator ready interrupt flag bit 20 PLLRDYC WO Clear the PLL-ready interrupt flag bit 23 CSSC WO Clear the clock security system interrupt flag bit The first 5 table entries are interrupt flags, indicated by the trailing F, and are read-only because they are set by hardware. The last 5 table entries are fields used to clear the interrupt flags, indicated by the trailing C, and are write-only. Because the interrupt flags are set by hardware, these fields are needed to physically “reset” the corresponding hardware, which will in turn clear the corresponding interrupt flag. Finally, the middle 4 table entries are interrupt enable fields, indicated by the trailing IE. When set to 1 an interrupt will be generated when the corresponding interrupt flag is set.\nFor our use case, we actually only need to clear certain interrupt flags in order to know when certain events happend (e.g. we’ll need to know when PLL is ready after we have enabled it), but clearing all of the interrupt flags is a good idea when changing the clock tree configuration anyway, so we’ll do that. Also, we could write our program in a way that doesn’t actively wait for the peripherals to be ready by utilizing interrupts but that would complicate our code, so we’ll disable interrupts too:\n# CSSC (bit 23) = 1 -\u003e clear CSSF (clock security system interrupt flag bit) # PLLRDYC (bit 20) = 1 -\u003e clear PLLRDYF (PLL-ready interrupt flag bit) # HSERDYC (bit 19) = 1 -\u003e clear HSERDYF (HSE oscillator ready interrupt flag bit) # HSIRDYC (bit 18) = 1 -\u003e clear HSIRDYF (HSI oscillator ready interrupt flag bit) # LSIRDYC (bit 16) = 1 -\u003e clear LSIRDYF (LSI oscillator ready interrupt flag bit) # PLLRDYIE (bit 12) = 0 -\u003e disable PLL-ready interrupt # HSERDYIE (bit 11) = 0 -\u003e disable HSE-ready interrupt # HSIRDYIE (bit 10) = 0 -\u003e disable HSI-ready interrupt # LSIRDYIE (bit 8) = 0 -\u003e disable LSI-ready interrupt # RCC_INTR = 1\u003c\u003c23 | 1\u003c\u003c20 | 1\u003c\u003c19 | 1\u003c\u003c18 | 1\u003c\u003c16 | 0\u003c\u003c12 | 0\u003c\u003c11 | 0\u003c\u003c10 | 0\u003c\u003c8 # RCC_INTR = 0b 0000 0000 1001 1101 0000 0000 0000 0000 # RCC_INTR = 0x009d0000 li t0, 0x009d0000 sw t0, 8(a0) Configure flash to use 1 cycle latency Flash latency is configured through R32_FLASH_ACTLR field LATENCY (bits 0-1); writing a 1 will select a 1 cycle latency:\n# configure flash to recommended settings for 48MHz clock # LATENCY (bits 0-1) = 1 # FLASH_ACTLR = 1 \u003c\u003c 0 # FLASH_ACTLR = 1 li t0, 0x00000001 sw t0, 0(a1) Wait until PLL is ready When PLL is ready RCC_CTLR field PLLRDY (bit 25) will be set to 1. So we could write a loop that iterates until PLLRDY is set:\n# wait until PLL is ready li t1, 0x02000000 # PLL_RDY mask = 1 \u003c\u003c 25 .L_pll_rdy_wait: lw t0, 0(a0) and t0, t0, t1 beq t0, zero, .L_pll_rdy_wait Select PLL as SYSCLK Once PLL is ready we can select it as SYSCLK source, which is done by setting R32_RCC_CFGR0 field SW (bits 0-1) to 2. Because we don’t want to modify the rest of the fields we could read the register value, set the first two bits to 0 with a bitwise AND mask (which would be 0b11 \u003c\u003c 0 = 0x00000003) and then bitwise OR the result with 2:\n# RCC_CFGR0 = RCC_CFGR0 \u0026 ~(0b11) | 0b10 # RCC_CFGR0 = RCC_CFGR0 \u0026 ~(0x00000003) | 0x00000002 # RCC_CFGR0 = RCC_CFGR0 \u0026 0xfffffffc | 0x00000002 lw t0, 4(a0) # t0 = RCC_CFGR0 and t0, t0, 0xfffffffc # clear clock source selection ~(0x00000003) = 0xfffffffc or t0, t0, 0x00000002 # select PLL as clock source 0x00000002 sw t0, 4(a0) Wait until PLL is used as SYSCLK When PLL is selected as clock source R32_RCC_CFGR0 field SWS (bits 2-3) will be set to 2 (the same value we set field SW to in the previous step). We could write a loop that iterates until SWS is set to 2:\n# wait until PLL is used as SYSCLK li t1, 0x0000000c # RCC_CFGR0 SWS mask li t2, 0x00000008 # RCC_CFGR0 SW PLL .L_pll_use_wait: lw t0, 4(a0) and t0, t0, t1 bne t0, t2, .L_pll_use_wait GPIO port setup Before we can set a pin high or low we have to enable the corresponding GPIO port and configure the individual pin as output.\nEnabling the GPIO port is done through R32_RCC_APB2PCENR field IOPDEN (bit 5) which enables (when set to 1) disables (when set to 0) GPIO port D clock:\n# setup GPIO pin for led # enable GPIO port D clock # RCC_AP2PCENR = RCC_AP2PCENR | 1 \u003c\u003c 5 # RCC_AP2PCENR = RCC_AP2PCENR | 0x00000020 lw t0, 24(a0) # t0 = APB2PCENR or t0, t0, 0x00000020 # APB2PCENR | EPB2PCENR_IOPDEN sw t0, 24(a0) Configuring the GPIO pin involves the GPIO registers, where each port has a different base address:\nNote: R32_GPIOX_CFGLR address and the next register address, R32_GPIOX_INDR, have an 8 byte difference. Since each register occupies 4 bytes that means there’s a reserved register between them. On other chips of the CH32 family this space is used for R32_GPIOX_CFGHR (Configuration High Register) which controls another 8 pins, doubling the amount of pins for each GPIO port. Even though this register is not present in the CH32V003 it is left blank to maintain register address consistency within the chip family.\nMore specifically, the R32_GPIOX_CFGLR (Configuration Low Register) is used to configure GPIO port D pins 0-7:\nSo, if we want to configure pin 4 we have to write to fields MODE4 (bits 16-17) and CNF4 (bits 18-19). To control the LED we want to set MODE4 to 1, which indicates output at 10MHz maximum speed, and CNF4 to 0, which indicates push-pull output mode. Because we don’t want to overwrite the rest of pin configurations we could first perform a bitwise AND with a mask to clear the previous configuration and then bitwise OR the result with the new configuration:\n# clear current pin config with an and mask (shift count determined by pin number * pin conf bit count -\u003e pin*4) # GPIOD_CFGLR = GPIOD_CFGLR \u0026 ~(0xf \u003c\u003c (4*pin)) | ((0|1) \u003c\u003c (4*pin)) lw t0, 0(a2) li t1, ~(0x0f \u003c\u003c (4 * led_pin)) and t0, t0, t1 li t1, 0x00000001 \u003c\u003c (4 * led_pin) or t0, t0, t1 sw t0, 0(a2) System tick counter as timer The system counter is a device that increments a register value on every clock cycle. It has a special register that allows us to set a comparison value so that when the counter value exceeds the comparison value a flag is set. We can use this to time actions in terms of clock cycles. These are its registers:\nR32_STK_CTLR is used to control the system counter:\nThe fields SWIE (software interrupt trigger enable) and STIE (counter interrupt enable) are both used to enable/disabled interrupts. Because we won’t be using interrupts we’ll set them both to 0.\nField STRE (System Tick auto-Reload Enable) is used to configure whether the counter resets to 0 after the comparison values has been reached or if it continues counting up to the maximum value. We don’t really care about this as we’ll stop the counter as soon as we detect the comparison value has been reached.\nField STCLK (system tick clock source) is used to select the counter clock source: HCLK (when set to 1) or HCLK/8 (when set to 0). It doesn’t really matter which setting we use as long as we take it into consideration when calculating the amount of ticks to set the counter to. We’ll use HCLK/8 as clock source as it allows for longer time delays.\nField STE (system tick enable) is used to turn on the counter (when set to 1) or turn it off (when set to 0).\nR32_STK_SR has a single 1-bit field, CNTIF, which is set to 1 when the counter reaches the comparison value:\nR32_STK_CNTL has a single 32-bit field, CNT, which holds the current counter value:\nR32_STK_CMPLR has a single 32-bit field, CMP, which holds the comparison value:\nGiven this set of registers, implementing a system tick delay function is reasonably simple:\nTurn system tick counter off and set clock source as HCLK/8 Clear the comparison flag Set initial counter value Set comparison counter value Turn system tick counter on Wait until the comparison flag is set Turn system tick counter off Let’s write a function waits until the number of ticks (HCLK/8) in register a0 have been reached:\ndelay_systick: # function prologue addi sp, sp, -16 sw ra, 12(sp) sw s0, 8(sp) sw s1, 4(sp) li s1, systck_base # s1 -\u003e system tick register base address # stop system counter (set STE [bit 0] to 0) and select HCLK/8 as clock source (set STCLK [bit 2] to 0) # STK_CTLR = STK_CTLR \u0026 ~((1\u003c\u003c0) | (1\u003c\u003c2)) # STK_CTLR = STK_CTLR \u0026 ~(0x00000005) # STK_CTLR = STK_CTLR \u0026 ~(0x00000005) # STK_CTLR = STK_CTLR \u0026 0xfffffffa lw s0, 0(s1) and s0, s0, 0xfffffffa sw s0, 0(s1) # clear count value comparison flag (set CNTIF [bit 0] to 0) # STK_SR = STK_SR \u0026 ~(1\u003c\u003c0) # STK_SR = STK_SR \u0026 0xfffffffe li s0, 0xfffffffe # s0 = ~(1) sw s0, 4(s1) # set initial counter value # STK_CNTL = 0 sw zero, 8(s1) # set count end value # STK_CMPLR = a0 sw a0, 16(s1) # start system counter (set STE [bit 0] to 1) # STK_CTLR = STK_CTLR | (1\u003c\u003c0) # STK_CTLR = STK_CTLR | 0x00000001 lw s0, 0(s1) or s0, s0, 0x00000001 sw s0, 0(s1) # wait until count system counter has reached target number .L_wait: lw s0, 4(s1) # s0 = STK_SR and s0, s0, 0x00000001 # s0 = STK_SR \u0026 0x00000001 beq s0, zero, .L_wait # if s0 != 0 -\u003e bit 0 is set -\u003e count has been reached # stop system counter (set STE [bit 0] to 0) # STK_CTLR = STK_CTLR \u0026 ~(1\u003c\u003c0) # STK_CTLR = STK_CTLR \u0026 0xfffffffe lw s0, 0(s1) and s0, s0, 0xfffffffe sw s0, 0(s1) # function epilogue lw s1, 4(sp) lw s0, 8(sp) lw ra, 12(sp) addi sp, sp, 16 ret Making the LED blink Now all that remains is to actually make the LED blink by setting GPIO D4 high and low in between delay_systick calls. There are two registers we can use to set any given GPIO pin high or low.\nR32_GPIOX_BCR is only used to reset (set to low state) any pin in the GPIO port by writing a 1 to the corresponding field:\nR32_GPIOX_BSHR is used for both setting (set to high state) and resetting (set to low state) any given pin in the GPIO port. Works identically to R32_GPIOX_BCR but the set fields are on the lower 16 bits and the reset fields are on the higher 16 bits. This register is useful for setting and resetting different pins at the same time and in scenarios where immediate execution of the next instruction is not guaranteed (when interrupts are enabled or on multicore CPUs) because it can be done in a single atomic operation.\nBecause we want to have the LED on and off for a certain amount of time we have to convert that amount to number of system ticks in order to use the delay_systick function. For a 48MHz system clock source we could calculate the milisecond to tick factor the following way:\n$$ \\frac{48000000cycle}{1s} \\cdot \\frac{1tick}{8cycle} \\cdot \\frac{1s}{1000ms} = 6000 ticks/ms $$\nFinally, we can write an infinite loop to blink the LED:\nli t2, 1 \u003c\u003c led_pin # pin mask .L_loop: sw t2, 20(a2) # GPIO_BCR = (1 \u003c\u003c led_pin) li a0, 100*ms_to_tick # keep led on for 100ms call delay_systick sw t2, 16(a2) # GPIO_BSHR = (1 \u003c\u003c led_pin) li a0, 1000*ms_to_tick # keep led off for 1000ms call delay_systick j .L_loop ","wordCount":"3460","inLanguage":"en","datePublished":"2025-02-27T00:00:00Z","dateModified":"2025-02-27T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://hexdhog.com/posts/bare-blinky/"},"publisher":{"@type":"Organization","name":"hexdhog","logo":{"@type":"ImageObject","url":"https://hexdhog.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://hexdhog.com/ accesskey=h title="hexdhog (Alt + H)">hexdhog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Bare blinky</h1><div class=post-meta><span title='2025-02-27 00:00:00 +0000 UTC'>February 27, 2025</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#setup aria-label=Setup>Setup</a></li><li><a href=#plan aria-label=Plan>Plan</a></li><li><a href=#system-clock-setup aria-label="System clock setup">System clock setup</a><ul><li><a href=#enable-hsi-and-pll aria-label="Enable HSI and PLL">Enable HSI and PLL</a></li><li><a href=#select-hsi-as-pll-source-and-turn-off-prescaler aria-label="Select HSI as PLL source and turn off prescaler">Select HSI as PLL source and turn off prescaler</a></li><li><a href=#clear-rcc-interrupt-flags aria-label="Clear RCC interrupt flags">Clear RCC interrupt flags</a></li><li><a href=#configure-flash-to-use-1-cycle-latency aria-label="Configure flash to use 1 cycle latency">Configure flash to use 1 cycle latency</a></li><li><a href=#wait-until-pll-is-ready aria-label="Wait until PLL is ready">Wait until PLL is ready</a></li><li><a href=#select-pll-as-sysclk aria-label="Select PLL as SYSCLK">Select PLL as SYSCLK</a></li><li><a href=#wait-until-pll-is-used-as-sysclk aria-label="Wait until PLL is used as SYSCLK">Wait until PLL is used as SYSCLK</a></li></ul></li><li><a href=#gpio-port-setup aria-label="GPIO port setup">GPIO port setup</a></li><li><a href=#system-tick-counter-as-timer aria-label="System tick counter as timer">System tick counter as timer</a></li><li><a href=#making-the-led-blink aria-label="Making the LED blink">Making the LED blink</a></li></ul></div></details></div><div class=post-content><p>I have messed with electronics for quite some time now, pretty much ever since I started programming. Actually, I learned basic C programming by playing in Arduino IDE. So I have a decent understanding of how to write basic programs that run on Arduino-like compatible microcontrollers; but I have a mediocre understanding of what is actually going on when I use the Arduino or, even, the chip&rsquo;s framework. So I want to go down the software stack and understand exactly what really happens under the hood. I think making an LED blink, an extremely basic task, in assembly and without any libraries/frameworks is a decent starting point.</p><hr><h2 id=setup>Setup<a hidden class=anchor aria-hidden=true href=#setup>#</a></h2><p>I bought a <a href=https://es.aliexpress.com/item/1005005834050641.html>CH32V003 kit</a> a while back with this goal in mind.</p><p>It&rsquo;s a microcontroller based on QuingKe RISC-V2A with 2KB SRAM, 16KB FLASH, PFIC and comes with a bunch of very common peripherals (e.g. I2C, USART, SPI, ADC, etc). The kit also includes a WCH-LinkE, a USB to SWIO bridge, which is used to program the microcontroller and monitor the USART interface.</p><p>I am using PlatformIO to manage the project, although that isn&rsquo;t really relevant to this post.</p><hr><h2 id=plan>Plan<a hidden class=anchor aria-hidden=true href=#plan>#</a></h2><p>The CH32V003 kit&rsquo;s PCB has an LED connected to GPIO D4 which emits light when that pin is low. So we need a way to manipulate the GPIO pin. Then we need a way to time the actions perfomed on the GPIO pin, so that the LED actually blinks and it does so at a constant rate.</p><p>The following block diagram depicts the CH32V003 system architecture:</p><p><img alt="CH32V003 system architecture block diagram" loading=lazy src=/img/ch32v003-block-diagram.png></p><p>There are three GPIO ports: GPIOA (PA1-PA2), GPIOC (PC0-PC7) and GPIOD (PD0-PD7) which are completely seperate GPIO controllers. Like most peripherals, they are accessed through the <a href=https://en.wikipedia.org/wiki/Advanced_Microcontroller_Bus_Architecture>AHB bus</a>. Each of these peripheral controllers has a set of registers that control the behaviour of the actual peripheral, and each of these registers is wired to the bus. Additionally, although not specified in the block diagram, the CH32V003 core has a system tick counter which we can use to time the GPIO actions. Like the peripherals on the AHB bus, it has a set of registers that control its behaviour.</p><p>This is what&rsquo;s called <a href=https://en.wikipedia.org/wiki/Memory-mapped_I/O_and_port-mapped_I/O>Memory Mapped IO</a>, and it is very common in microcontrollers. The registers from the peripheral controllers are each assigned a unique memory address. Therefore, interfacing with each register translates to a read and/or write operation from/to the bus. The CH32V003 has the following memory map:</p><p><img alt="CH32V003 memory map" loading=lazy src=/img/ch32v003-memory-map.png></p><p>Note that FLASH and SRAM are also peripherals and, while they are connected on different buses, are accesed in the same way as any other peripheral. This means that all components are wired in a way such that when the RISC-V2A core selects an address to read/write to, the correct bus and peripheral controller register is enabled and given access to the bus. So to us, the RISC-V2A core programmers, accessing any peripheral is analogous to reading/writing data to memory.</p><p>According to the memory map diagram, the GPIO port D registers are located between addresses <code>0x40011400</code> and <code>0x40011800</code>, and, though not specified, the system tick timer&rsquo;s registers are located in the Core Private Peripherals section (<code>0xe000000</code> to <code>0xe0100000</code>).</p><hr><h2 id=system-clock-setup>System clock setup<a hidden class=anchor aria-hidden=true href=#system-clock-setup>#</a></h2><p>Before setting anything else up we should initialize the system clock. After reset, the CH32V003 uses the HSI (High Speed Internal) oscillator at 24MHz as a clock source. The <a href=https://en.wikipedia.org/wiki/Phase-locked_loop>PLL (Phase Locked Loop)</a>, used to multiply the input clock source, is disabled. An HSE (High Speed Extenal) oscillator 4-25MHz can also be used as a clock source which is disabled after reset; up to de user to set it up on every startup.</p><p>The following block diagram shows the system clock tree:</p><p><img alt="CH32V003 clock tree block diagram" loading=lazy src=/img/ch32v003-clock-tree.png></p><p>A few important notes about the clock tree that we should care about:</p><ul><li>HSE and HSI can multiplied by 2 through a PLL, so SYSCLK output is multiplexed between HSI, HSE, HSI*2 and HSE*2</li><li>HCLK is prescaled (divisible by: 1, 2, &mldr;, 256) from SYSCLK</li><li>HCLK is used for HB peripherals (GPIO)</li><li>HCLK is used for Core System Timer and can be divided by 8 (useful for longer timer delays)</li></ul><p>Because HCLK depends on SYSCLK, let&rsquo;s configure SYSCLK first. We&rsquo;ll configure it at 48MHz; the maximum supported frequency. Because we don&rsquo;t have an external crystal (HSE), we&rsquo;ll use the internal oscillator (HSI) which runs at 24MHz and feed it to the PLL to multiply it by 2 (24MHz * 2 = 48MHz). So first of all, we have to enable both HSI and PLL and configure HSI as PLL source. Then, because we&rsquo;ll need to kwow when PLL is ready before we can actually select it as a clock source, we should clear RCC interrupt flags. These flags indicate the state of different clock devices and are used to detect when different events happen, and PLL being ready is one of them. Because these flags don&rsquo;t auto-reset we have to reset them so that we can detect when PLL is ready. The next obvious step to finish SYSCLK configuration would be to select HSI+PLL (HSI*2) by selecting PLL as clock source, but before we do that we should configure everything that depends on SYSCLK so that when we do enable it everything else is setup and ready to go. For our use case there are two things to configure: HCLK prescaler configuration (we want to turn it off so that HCLK = SYSCLK = 48MHz) and flash with a 1 cycle latency (this is recommended in the reference manual when 24MHz &lt;= SYSCLK &lt;= 48MHz). The last thing to do is to wait for the PLL to be ready, select it as SYSCLK source and wait until it is actually used as SYSCLK before executing the rest of the program.</p><p>Because some of the steps detailed above can be perfomed at the same time we can optimise the list of steps to look like this:</p><ol><li><a href=#enable-hsi-and-pll>Enable HSI and PLL</a></li><li><a href=#select-hsi-as-pll-source-and-turn-off-prescaler>Select HSI as PLL source and turn off prescaler</a></li><li><a href=#clear-rcc-interrupt-flags>Clear RCC interrupt flags</a></li><li><a href=#configure-flash-to-use-1-cycle-latency>Configure flash to use 1 cycle latency</a></li><li><a href=#wait-until-pll-is-ready>Wait until PLL is ready</a></li><li><a href=#select-pll-as-sysclk>Select PLL as SYSCLK</a></li><li><a href=#wait-until-pll-is-used-as-sysclk>Wait until PLL is used as SYSCLK</a></li></ol><p>All of these steps are performed using the RCC (Reset and Clock Control) registers, with base address <code>0x40021000</code>:</p><p><img alt="CH32V003 RCC registers" loading=lazy src=/img/ch32v003-rcc-registers.png></p><p>and the FLASH registers, with base address <code>0x40022000</code>:</p><p><img alt="CH32V003 FLASH registers" loading=lazy src=/img/ch32v003-flash-registers.png></p><p>More specifically, we&rsquo;ll need the following registers:</p><p><strong>R32_RCC_CTLR</strong>
<img alt="CH32V003 R32_RCC_CTLR" loading=lazy src=/img/ch32v003-rcc-ctlr.png></p><p><strong>R32_RCC_CFGR0</strong>
<img alt="CH32V003 R32_RCC_CFGR0" loading=lazy src=/img/ch32v003-rcc-cfgr0.png></p><p><strong>R32_RCC_INTR</strong>
<img alt="CH32V003 R32_RCC_INTR" loading=lazy src=/img/ch32v003-rcc-intr.png></p><p><strong>R32_FLASH_ACTLR</strong>
<img alt="CH32V003 R32_FLASH_INTR" loading=lazy src=/img/ch32v003-flash-actlr.png></p><p><strong>Note</strong>: the description of each field for all registers is left out for brevity. More information can be found in the <a href=https://www.wch-ic.com/downloads/CH32V003RM_PDF.html>reference manual</a>.</p><h3 id=enable-hsi-and-pll>Enable HSI and PLL<a hidden class=anchor aria-hidden=true href=#enable-hsi-and-pll>#</a></h3><p>HSI and PLL are enabled through <code>R32_RCC_CTLR</code> field <code>HSION</code> (bit 0) and field <code>PLLON</code> (bit 24). For both fields, writing a 1 will enable the device and writing a 0 will disable it. So let&rsquo;s write some RISC-V assembly code that enables them both:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#57c7ff>.equ</span> <span style=color:#ff9f43>rcc_base</span>, <span style=color:#ff9f43>0x40021000</span>
</span></span><span style=display:flex><span><span style=color:#57c7ff>.equ</span> <span style=color:#ff9f43>flash_r_base</span>, <span style=color:#ff9f43>0x40022000</span>
</span></span><span style=display:flex><span><span style=color:#57c7ff>.equ</span> <span style=color:#ff9f43>gpio_pd_base</span>, <span style=color:#ff9f43>0x40011400</span>
</span></span><span style=display:flex><span><span style=color:#57c7ff>.equ</span> <span style=color:#ff9f43>systck_base</span>, <span style=color:#ff9f43>0xe000f000</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#57c7ff>.equ</span> <span style=color:#ff9f43>led_pin</span>, <span style=color:#ff9f43>4</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#57c7ff>.globl</span> <span style=color:#ff9f43>main</span>
</span></span><span style=display:flex><span><span style=color:#ff5c57>main:</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>a0</span>, <span style=color:#ff9f43>rcc_base</span> <span style=color:#78787e># a0 -&gt; RCC register base address
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>a1</span>, <span style=color:#ff9f43>flash_r_base</span> <span style=color:#78787e># a1 -&gt; FLASH register base address
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>a2</span>, <span style=color:#ff9f43>gpio_pd_base</span> <span style=color:#78787e># a2 -&gt; GPIO port d register base address
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># PLL_ON (bit 0): enable PLL
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># HSI_ON (bit 24): enable HSI
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     RCC CTLR = 1 &lt;&lt; 0 | 1 &lt;&lt; 24
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     RCC CTLR = 0x01000001
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0x01000001</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>a0</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>a0</span>, <span style=color:#ff9f43>rcc_base</span> <span style=color:#78787e># a0 -&gt; RCC register base address
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>a1</span>, <span style=color:#ff9f43>flash_r_base</span> <span style=color:#78787e># a1 -&gt; FLASH register base address
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>a2</span>, <span style=color:#ff9f43>gpio_pd_base</span> <span style=color:#78787e># a2 -&gt; GPIO port d register base address
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># PLL_ON (bit 0): enable PLL
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># HSI_ON (bit 24): enable HSI
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     RCC CTLR = 1 &lt;&lt; 0 | 1 &lt;&lt; 24
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     RCC CTLR = 0x01000001
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0x01000001</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>a0</span>)
</span></span></code></pre></div><p><strong>Note:</strong> a few lines of code have been added, like constant definitions, which will be needed later.</p><h3 id=select-hsi-as-pll-source-and-turn-off-prescaler>Select HSI as PLL source and turn off prescaler<a hidden class=anchor aria-hidden=true href=#select-hsi-as-pll-source-and-turn-off-prescaler>#</a></h3><p>The prescaler is turned off by writing 0 to <code>R32_RCC_CFGR0</code> field <code>HPRE</code> (bits 4-7) and HSI is selected as PLL source by writing 0 to field <code>PLLSRC</code> (bit 16):</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>        <span style=color:#78787e># HPRE = 0: prescaler off; do not divide SYSCLK
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># PLLSRC = 0: HSI (instead of HSE) for PLL input
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     RCC_CFGR0 = 0 &lt;&lt; 4 | 0 &lt;&lt; 16
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     RCC_CFGR0 = 0
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0x00000000</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>4</span>(<span style=color:#ff9f43>a0</span>)
</span></span></code></pre></div><h3 id=clear-rcc-interrupt-flags>Clear RCC interrupt flags<a hidden class=anchor aria-hidden=true href=#clear-rcc-interrupt-flags>#</a></h3><p>Clearing the RCC interrupt flags, actually involves all <code>R32_RCC_INTR</code> fields, so let&rsquo;s take a closer look at them to better understand how this register works:</p><table><thead><tr><th>bit</th><th>name</th><th>access</th><th>description</th></tr></thead><tbody><tr><td>0</td><td><code>LSIRDYF</code></td><td>RO</td><td>LSI clock-ready interrupt flag</td></tr><tr><td>2</td><td><code>HSIRDYF</code></td><td>RO</td><td>HSI clock-ready interrupt flag</td></tr><tr><td>3</td><td><code>HSERDYF</code></td><td>RO</td><td>HSE clock-ready interrupt flag</td></tr><tr><td>4</td><td><code>PLLRDYF</code></td><td>RO</td><td>PLL clock-ready lockout interrupt flag</td></tr><tr><td>7</td><td><code>CSSF</code></td><td>RO</td><td>Clock security system interrupt flag bit</td></tr><tr><td>8</td><td><code>LSIRDYIE</code></td><td>RW</td><td>LSI-ready interrupt enable bit</td></tr><tr><td>10</td><td><code>HSIRDYIE</code></td><td>RW</td><td>HSI-ready interrupt enable bit</td></tr><tr><td>11</td><td><code>HSERDYIE</code></td><td>RW</td><td>HSE-ready interrupt enable bit</td></tr><tr><td>12</td><td><code>PLLRDYIE</code></td><td>RW</td><td>PLL-ready interrupt enable bit</td></tr><tr><td>16</td><td><code>LSIRDYC</code></td><td>WO</td><td>Clear the LSI oscillator ready interrupt flag bit</td></tr><tr><td>19</td><td><code>HSERDYC</code></td><td>WO</td><td>Clear the HSE oscillator ready interrupt flag bit</td></tr><tr><td>18</td><td><code>HSIRDYC</code></td><td>WO</td><td>Clear the HSI oscillator ready interrupt flag bit</td></tr><tr><td>20</td><td><code>PLLRDYC</code></td><td>WO</td><td>Clear the PLL-ready interrupt flag bit</td></tr><tr><td>23</td><td><code>CSSC</code></td><td>WO</td><td>Clear the clock security system interrupt flag bit</td></tr></tbody></table><p>The first 5 table entries are interrupt flags, indicated by the trailing <code>F</code>, and are read-only because they are set by hardware. The last 5 table entries are fields used to clear the interrupt flags, indicated by the trailing <code>C</code>, and are write-only. Because the interrupt flags are set by hardware, these fields are needed to physically &ldquo;reset&rdquo; the corresponding hardware, which will in turn clear the corresponding interrupt flag. Finally, the middle 4 table entries are interrupt enable fields, indicated by the trailing <code>IE</code>. When set to 1 an interrupt will be generated when the corresponding interrupt flag is set.</p><p>For our use case, we actually only <em>need</em> to clear certain interrupt flags in order to know when certain events happend (e.g. we&rsquo;ll need to know when PLL is ready after we have enabled it), but clearing all of the interrupt flags is a good idea when changing the clock tree configuration anyway, so we&rsquo;ll do that. Also, we could write our program in a way that doesn&rsquo;t actively wait for the peripherals to be ready by utilizing interrupts but that would complicate our code, so we&rsquo;ll disable interrupts too:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>        <span style=color:#78787e># CSSC     (bit 23) = 1 -&gt; clear CSSF (clock security system interrupt flag bit)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># PLLRDYC  (bit 20) = 1 -&gt; clear PLLRDYF (PLL-ready interrupt flag bit)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># HSERDYC  (bit 19) = 1 -&gt; clear HSERDYF (HSE oscillator ready interrupt flag bit)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># HSIRDYC  (bit 18) = 1 -&gt; clear HSIRDYF (HSI oscillator ready interrupt flag bit)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># LSIRDYC  (bit 16) = 1 -&gt; clear LSIRDYF (LSI oscillator ready interrupt flag bit)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># PLLRDYIE (bit 12) = 0 -&gt; disable PLL-ready interrupt
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># HSERDYIE (bit 11) = 0 -&gt; disable HSE-ready interrupt
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># HSIRDYIE (bit 10) = 0 -&gt; disable HSI-ready interrupt
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># LSIRDYIE (bit  8) = 0 -&gt; disable LSI-ready interrupt
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     RCC_INTR = 1&lt;&lt;23 | 1&lt;&lt;20 | 1&lt;&lt;19 | 1&lt;&lt;18 | 1&lt;&lt;16 | 0&lt;&lt;12 | 0&lt;&lt;11 | 0&lt;&lt;10 | 0&lt;&lt;8
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     RCC_INTR = 0b 0000 0000 1001 1101 0000 0000 0000 0000
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     RCC_INTR = 0x009d0000
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0x009d0000</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>8</span>(<span style=color:#ff9f43>a0</span>)
</span></span></code></pre></div><h3 id=configure-flash-to-use-1-cycle-latency>Configure flash to use 1 cycle latency<a hidden class=anchor aria-hidden=true href=#configure-flash-to-use-1-cycle-latency>#</a></h3><p>Flash latency is configured through <code>R32_FLASH_ACTLR</code> field <code>LATENCY</code> (bits 0-1); writing a 1 will select a 1 cycle latency:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>        <span style=color:#78787e># configure flash to recommended settings for 48MHz clock
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># LATENCY (bits 0-1) = 1
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     FLASH_ACTLR = 1 &lt;&lt; 0
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     FLASH_ACTLR = 1
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0x00000001</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>a1</span>)
</span></span></code></pre></div><h3 id=wait-until-pll-is-ready>Wait until PLL is ready<a hidden class=anchor aria-hidden=true href=#wait-until-pll-is-ready>#</a></h3><p>When PLL is ready <code>RCC_CTLR</code> field <code>PLLRDY</code> (bit 25) will be set to 1. So we could write a loop that iterates until <code>PLLRDY</code> is set:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>        <span style=color:#78787e># wait until PLL is ready
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>t1</span>, <span style=color:#ff9f43>0x02000000</span> <span style=color:#78787e># PLL_RDY mask = 1 &lt;&lt; 25
</span></span></span><span style=display:flex><span><span style=color:#78787e></span><span style=color:#ff5c57>.L_pll_rdy_wait:</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>a0</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>and</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t1</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>beq</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>zero</span>, <span style=color:#ff9f43>.L_pll_rdy_wait</span>
</span></span></code></pre></div><h3 id=select-pll-as-sysclk>Select PLL as SYSCLK<a hidden class=anchor aria-hidden=true href=#select-pll-as-sysclk>#</a></h3><p>Once PLL is ready we can select it as SYSCLK source, which is done by setting <code>R32_RCC_CFGR0</code> field <code>SW</code> (bits 0-1) to 2. Because we don&rsquo;t want to modify the rest of the fields we could read the register value, set the first two bits to 0 with a bitwise AND mask (which would be <code>0b11 &lt;&lt; 0 = 0x00000003</code>) and then bitwise OR the result with 2:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>        <span style=color:#78787e># RCC_CFGR0 = RCC_CFGR0 &amp; ~(0b11) | 0b10
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># RCC_CFGR0 = RCC_CFGR0 &amp; ~(0x00000003) | 0x00000002
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># RCC_CFGR0 = RCC_CFGR0 &amp; 0xfffffffc | 0x00000002
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>4</span>(<span style=color:#ff9f43>a0</span>) <span style=color:#78787e># t0 = RCC_CFGR0
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>and</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0xfffffffc</span> <span style=color:#78787e># clear clock source selection ~(0x00000003) = 0xfffffffc
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>or</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0x00000002</span> <span style=color:#78787e># select PLL as clock source 0x00000002
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>4</span>(<span style=color:#ff9f43>a0</span>)
</span></span></code></pre></div><h3 id=wait-until-pll-is-used-as-sysclk>Wait until PLL is used as SYSCLK<a hidden class=anchor aria-hidden=true href=#wait-until-pll-is-used-as-sysclk>#</a></h3><p>When PLL is selected as clock source <code>R32_RCC_CFGR0</code> field <code>SWS</code> (bits 2-3) will be set to 2 (the same value we set field <code>SW</code> to in the previous step). We could write a loop that iterates until <code>SWS</code> is set to 2:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>        <span style=color:#78787e># wait until PLL is used as SYSCLK
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>t1</span>, <span style=color:#ff9f43>0x0000000c</span> <span style=color:#78787e># RCC_CFGR0 SWS mask
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>t2</span>, <span style=color:#ff9f43>0x00000008</span> <span style=color:#78787e># RCC_CFGR0 SW PLL
</span></span></span><span style=display:flex><span><span style=color:#78787e></span><span style=color:#ff5c57>.L_pll_use_wait:</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>4</span>(<span style=color:#ff9f43>a0</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>and</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t1</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>bne</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t2</span>, <span style=color:#ff9f43>.L_pll_use_wait</span>
</span></span></code></pre></div><hr><h2 id=gpio-port-setup>GPIO port setup<a hidden class=anchor aria-hidden=true href=#gpio-port-setup>#</a></h2><p>Before we can set a pin high or low we have to enable the corresponding GPIO port and configure the individual pin as output.</p><p>Enabling the GPIO port is done through <code>R32_RCC_APB2PCENR</code> field <code>IOPDEN</code> (bit 5) which enables (when set to 1) disables (when set to 0) GPIO port D clock:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>        <span style=color:#78787e># setup GPIO pin for led
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># enable GPIO port D clock
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># RCC_AP2PCENR = RCC_AP2PCENR | 1 &lt;&lt; 5
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># RCC_AP2PCENR = RCC_AP2PCENR | 0x00000020
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>24</span>(<span style=color:#ff9f43>a0</span>) <span style=color:#78787e># t0 = APB2PCENR
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>or</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0x00000020</span> <span style=color:#78787e># APB2PCENR | EPB2PCENR_IOPDEN
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>24</span>(<span style=color:#ff9f43>a0</span>)
</span></span></code></pre></div><p>Configuring the GPIO pin involves the GPIO registers, where each port has a different base address:</p><p><img alt="CH32V003 GPIO registers" loading=lazy src=/img/ch32v003-gpio-registers.png></p><p><strong>Note</strong>: <code>R32_GPIOX_CFGLR</code> address and the next register address, <code>R32_GPIOX_INDR</code>, have an 8 byte difference. Since each register occupies 4 bytes that means there&rsquo;s a reserved register between them. On other chips of the CH32 family this space is used for <code>R32_GPIOX_CFGHR</code> (Configuration High Register) which controls another 8 pins, doubling the amount of pins for each GPIO port. Even though this register is not present in the CH32V003 it is left blank to maintain register address consistency within the chip family.</p><p>More specifically, the <code>R32_GPIOX_CFGLR</code> (Configuration Low Register) is used to configure GPIO port D pins 0-7:</p><p><img alt="CH32V003 GPIO CFGLR" loading=lazy src=/img/ch32v003-gpio-cfglr.png></p><p>So, if we want to configure pin 4 we have to write to fields <code>MODE4</code> (bits 16-17) and <code>CNF4</code> (bits 18-19). To control the LED we want to set <code>MODE4</code> to 1, which indicates output at 10MHz maximum speed, and <code>CNF4</code> to 0, which indicates push-pull output mode. Because we don&rsquo;t want to overwrite the rest of pin configurations we could first perform a bitwise AND with a mask to clear the previous configuration and then bitwise OR the result with the new configuration:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>        <span style=color:#78787e># clear current pin config with an and mask (shift count determined by pin number * pin conf bit count -&gt; pin*4)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># GPIOD_CFGLR = GPIOD_CFGLR &amp; ~(0xf &lt;&lt; (4*pin)) | ((0|1) &lt;&lt; (4*pin))
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>a2</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>t1</span>, <span style=color:#ff5c57>~</span>(<span style=color:#ff9f43>0x0f</span> <span style=color:#ff5c57>&lt;&lt;</span> (<span style=color:#ff9f43>4</span> * <span style=color:#ff9f43>led_pin</span>))
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>and</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>t1</span>, <span style=color:#ff9f43>0x00000001</span> <span style=color:#ff5c57>&lt;&lt;</span> (<span style=color:#ff9f43>4</span> * <span style=color:#ff9f43>led_pin</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>or</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t1</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>a2</span>)
</span></span></code></pre></div><hr><h2 id=system-tick-counter-as-timer>System tick counter as timer<a hidden class=anchor aria-hidden=true href=#system-tick-counter-as-timer>#</a></h2><p>The system counter is a device that increments a register value on every clock cycle. It has a special register that allows us to set a comparison value so that when the counter value exceeds the comparison value a flag is set. We can use this to time actions in terms of clock cycles. These are its registers:</p><p><img alt="CH32V003 STK registers" loading=lazy src=/img/ch32v003-stk-registers.png></p><p><code>R32_STK_CTLR</code> is used to control the system counter:</p><p><img alt="CH32V003 STK CTLR" loading=lazy src=/img/ch32v003-stk-ctlr.png></p><p>The fields <code>SWIE</code> (software interrupt trigger enable) and <code>STIE</code> (counter interrupt enable) are both used to enable/disabled interrupts. Because we won&rsquo;t be using interrupts we&rsquo;ll set them both to 0.</p><p>Field <code>STRE</code> (System Tick auto-Reload Enable) is used to configure whether the counter resets to 0 after the comparison values has been reached or if it continues counting up to the maximum value. We don&rsquo;t really care about this as we&rsquo;ll stop the counter as soon as we detect the comparison value has been reached.</p><p>Field <code>STCLK</code> (system tick clock source) is used to select the counter clock source: HCLK (when set to 1) or HCLK/8 (when set to 0). It doesn&rsquo;t really matter which setting we use as long as we take it into consideration when calculating the amount of ticks to set the counter to. We&rsquo;ll use HCLK/8 as clock source as it allows for longer time delays.</p><p>Field <code>STE</code> (system tick enable) is used to turn on the counter (when set to 1) or turn it off (when set to 0).</p><p><code>R32_STK_SR</code> has a single 1-bit field, <code>CNTIF</code>, which is set to 1 when the counter reaches the comparison value:</p><p><img alt="CH32V003 STK CTLR" loading=lazy src=/img/ch32v003-stk-sr.png></p><p><code>R32_STK_CNTL</code> has a single 32-bit field, <code>CNT</code>, which holds the current counter value:</p><p><img alt="CH32V003 STK CTLR" loading=lazy src=/img/ch32v003-stk-cntl.png></p><p><code>R32_STK_CMPLR</code> has a single 32-bit field, <code>CMP</code>, which holds the comparison value:</p><p><img alt="CH32V003 STK CTLR" loading=lazy src=/img/ch32v003-stk-cmplr.png></p><p>Given this set of registers, implementing a system tick delay function is reasonably simple:</p><ol><li>Turn system tick counter off and set clock source as HCLK/8</li><li>Clear the comparison flag</li><li>Set initial counter value</li><li>Set comparison counter value</li><li>Turn system tick counter on</li><li>Wait until the comparison flag is set</li><li>Turn system tick counter off</li></ol><p>Let&rsquo;s write a function waits until the number of ticks (HCLK/8) in register <code>a0</code> have been reached:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#ff5c57>delay_systick:</span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># function prologue
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>addi</span> <span style=color:#ff9f43>sp</span>, <span style=color:#ff9f43>sp</span>, -<span style=color:#ff9f43>16</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>ra</span>, <span style=color:#ff9f43>12</span>(<span style=color:#ff9f43>sp</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>8</span>(<span style=color:#ff9f43>sp</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>s1</span>, <span style=color:#ff9f43>4</span>(<span style=color:#ff9f43>sp</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>s1</span>, <span style=color:#ff9f43>systck_base</span> <span style=color:#78787e># s1 -&gt; system tick register base address
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># stop system counter (set STE [bit 0] to 0) and select HCLK/8 as clock source (set STCLK [bit 2] to 0)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_CTLR = STK_CTLR &amp; ~((1&lt;&lt;0) | (1&lt;&lt;2))
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_CTLR = STK_CTLR &amp; ~(0x00000005)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_CTLR = STK_CTLR &amp; ~(0x00000005)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_CTLR = STK_CTLR &amp; 0xfffffffa
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>s1</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>and</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>0xfffffffa</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>s1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># clear count value comparison flag (set CNTIF [bit 0] to 0)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_SR = STK_SR &amp; ~(1&lt;&lt;0)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_SR = STK_SR &amp; 0xfffffffe
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>0xfffffffe</span> <span style=color:#78787e># s0 = ~(1)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>4</span>(<span style=color:#ff9f43>s1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># set initial counter value
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_CNTL = 0
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>zero</span>, <span style=color:#ff9f43>8</span>(<span style=color:#ff9f43>s1</span>)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#78787e># set count end value
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_CMPLR = a0
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>a0</span>, <span style=color:#ff9f43>16</span>(<span style=color:#ff9f43>s1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># start system counter (set STE [bit 0] to 1)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_CTLR = STK_CTLR | (1&lt;&lt;0)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_CTLR = STK_CTLR | 0x00000001
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>s1</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>or</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>0x00000001</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>s1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># wait until count system counter has reached target number
</span></span></span><span style=display:flex><span><span style=color:#78787e></span><span style=color:#ff5c57>.L_wait:</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>4</span>(<span style=color:#ff9f43>s1</span>) <span style=color:#78787e># s0 = STK_SR
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>and</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>0x00000001</span> <span style=color:#78787e># s0 = STK_SR &amp; 0x00000001
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>beq</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>zero</span>, <span style=color:#ff9f43>.L_wait</span> <span style=color:#78787e># if s0 != 0 -&gt; bit 0 is set -&gt; count has been reached
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># stop system counter (set STE [bit 0] to 0)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_CTLR = STK_CTLR &amp; ~(1&lt;&lt;0)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_CTLR = STK_CTLR &amp; 0xfffffffe
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>s1</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>and</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>0xfffffffe</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>s1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># function epilogue
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>s1</span>, <span style=color:#ff9f43>4</span>(<span style=color:#ff9f43>sp</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>8</span>(<span style=color:#ff9f43>sp</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>ra</span>, <span style=color:#ff9f43>12</span>(<span style=color:#ff9f43>sp</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>addi</span> <span style=color:#ff9f43>sp</span>, <span style=color:#ff9f43>sp</span>, <span style=color:#ff9f43>16</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>ret</span>
</span></span></code></pre></div><hr><h2 id=making-the-led-blink>Making the LED blink<a hidden class=anchor aria-hidden=true href=#making-the-led-blink>#</a></h2><p>Now all that remains is to actually make the LED blink by setting GPIO D4 high and low in between <code>delay_systick</code> calls. There are two registers we can use to set any given GPIO pin high or low.</p><p><code>R32_GPIOX_BCR</code> is only used to reset (set to low state) any pin in the GPIO port by writing a 1 to the corresponding field:</p><p><img alt="CH32V003 GPIO BCR" loading=lazy src=/img/ch32v003-gpio-bcr.png></p><p><code>R32_GPIOX_BSHR</code> is used for both setting (set to high state) and resetting (set to low state) any given pin in the GPIO port. Works identically to <code>R32_GPIOX_BCR</code> but the set fields are on the lower 16 bits and the reset fields are on the higher 16 bits. This register is useful for setting and resetting different pins at the same time and in scenarios where immediate execution of the next instruction is not guaranteed (when interrupts are enabled or on multicore CPUs) because it can be done in a single <em>atomic</em> operation.</p><p><img alt="CH32V003 GPIO BSHR" loading=lazy src=/img/ch32v003-gpio-bshr.png></p><p>Because we want to have the LED on and off for a certain amount of time we have to convert that amount to number of system ticks in order to use the <code>delay_systick</code> function. For a 48MHz system clock source we could calculate the milisecond to tick factor the following way:</p><p>$$
\frac{48000000cycle}{1s} \cdot \frac{1tick}{8cycle} \cdot \frac{1s}{1000ms} = 6000 ticks/ms
$$</p><p>Finally, we can write an infinite loop to blink the LED:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>t2</span>, <span style=color:#ff9f43>1</span> <span style=color:#ff5c57>&lt;&lt;</span> <span style=color:#ff9f43>led_pin</span> <span style=color:#78787e># pin mask
</span></span></span><span style=display:flex><span><span style=color:#78787e></span><span style=color:#ff5c57>.L_loop:</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>t2</span>, <span style=color:#ff9f43>20</span>(<span style=color:#ff9f43>a2</span>) <span style=color:#78787e># GPIO_BCR = (1 &lt;&lt; led_pin)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>a0</span>, <span style=color:#ff9f43>100</span>*<span style=color:#ff9f43>ms_to_tick</span> <span style=color:#78787e># keep led on for 100ms
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>call</span> <span style=color:#ff9f43>delay_systick</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>t2</span>, <span style=color:#ff9f43>16</span>(<span style=color:#ff9f43>a2</span>) <span style=color:#78787e># GPIO_BSHR = (1 &lt;&lt; led_pin)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>a0</span>, <span style=color:#ff9f43>1000</span>*<span style=color:#ff9f43>ms_to_tick</span> <span style=color:#78787e># keep led off for 1000ms
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>call</span> <span style=color:#ff9f43>delay_systick</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>j</span> <span style=color:#ff9f43>.L_loop</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://hexdhog.com/>hexdhog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>