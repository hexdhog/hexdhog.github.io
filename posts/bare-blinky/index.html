<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Bare blinky - serafi</title><meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="I have messed with electronics for quite some time now, pretty much ever since I started programming. Actually, I learned basic C programming by playing in Arduino IDE. So I have a decent understanding of how to write basic programs that run on Arduino-like compatible microcontrollers; but I have a mediocre understanding of what is actually going on when I use the Arduino or, even, the own chip&rsquo;s framework. So I want to go down the software stack and understand exactly what really happens under the hood. I think making an LED blink, an extremely basic task, in assembly and without any libraries/frameworks is a decent starting point."><meta property="og:image" content><meta property="og:url" content="https://blog.serafi.dev/posts/bare-blinky/"><meta property="og:site_name" content="serafi"><meta property="og:title" content="Bare blinky"><meta property="og:description" content="I have messed with electronics for quite some time now, pretty much ever since I started programming. Actually, I learned basic C programming by playing in Arduino IDE. So I have a decent understanding of how to write basic programs that run on Arduino-like compatible microcontrollers; but I have a mediocre understanding of what is actually going on when I use the Arduino or, even, the own chip’s framework. So I want to go down the software stack and understand exactly what really happens under the hood. I think making an LED blink, an extremely basic task, in assembly and without any libraries/frameworks is a decent starting point."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-05T00:00:00+00:00"><meta property="article:modified_time" content="2025-03-05T00:00:00+00:00"><meta property="article:tag" content="Ch32v003"><meta property="article:tag" content="Asm"><meta name=twitter:card content="summary"><meta name=twitter:title content="Bare blinky"><meta name=twitter:description content="I have messed with electronics for quite some time now, pretty much ever since I started programming. Actually, I learned basic C programming by playing in Arduino IDE. So I have a decent understanding of how to write basic programs that run on Arduino-like compatible microcontrollers; but I have a mediocre understanding of what is actually going on when I use the Arduino or, even, the own chip’s framework. So I want to go down the software stack and understand exactly what really happens under the hood. I think making an LED blink, an extremely basic task, in assembly and without any libraries/frameworks is a decent starting point."><link href=https://blog.serafi.dev/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://blog.serafi.dev/css/main.7a5c05040394322612a2d98397e9932aa81d9d7acc70199463e79f8180c8e0c0.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://blog.serafi.dev/css/dark.478e7f2b9cf8d87be42edfd9fe1810beab1331847df94b1b430478b309f28282.css disabled><link rel=stylesheet href=https://blog.serafi.dev/katex/katex.min.css><script defer src=https://blog.serafi.dev/katex/katex.min.js></script><script defer src=https://blog.serafi.dev/katex/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script></head><body><div class=content><link rel=icon href=/%20favicon.ico type=image/x-icon><main><article><div class=post-container><div class=post-content><div class=title><h1 class=title>Bare blinky</h1><div class=meta>Posted on Mar 5, 2025</div></div><section class=body><p>I have messed with electronics for quite some time now, pretty much ever since I started programming. Actually, I learned basic C programming by playing in Arduino IDE. So I have a decent understanding of how to write basic programs that run on Arduino-like compatible microcontrollers; but I have a mediocre understanding of what is actually going on when I use the Arduino or, even, the own chip&rsquo;s framework. So I want to go down the software stack and understand exactly what really happens under the hood. I think making an LED blink, an extremely basic task, in assembly and without any libraries/frameworks is a decent starting point.</p><h2 id=setup>Setup</h2><p>I bought a <a href=https://es.aliexpress.com/item/1005005834050641.html>CH32V003 kit</a> a while back with this goal in mind. It&rsquo;s a microcontroller based on QuingKe RISC-V2A with 2KB SRAM, 16KB FLASH, PFIC and comes with a bunch of very common peripherals (e.g. I2C, USART, SPI, ADC, etc). The kit also includes a WCH-LinkE, a USB to SWIO bridge, which is used to program the microcontroller and monitor the USART interface.</p><p>I am using PlatformIO to manage the project, although that isn&rsquo;t really relevant to this post. All of the code can be found on my <a href=https://github.com/hexdhog/ch32v003-blinky>GitHub repository</a>.</p><h2 id=plan>Plan</h2><p>The CH32V003 kit&rsquo;s PCB has an LED connected to GPIO D4 which emits light when that pin is low. So we need a way to manipulate the GPIO pin. Then we need a way to time the actions perfomed on the GPIO pin, so that the LED actually blinks and it does so at a constant rate.</p><p>The following block diagram depicts the CH32V003 system architecture:</p><p><img src=/img/ch32v003-block-diagram.png alt="CH32V003 system architecture block diagram"></p><p>There are three GPIO ports: GPIOA (PA1-PA2), GPIOC (PC0-PC7) and GPIOD (PD0-PD7) which are completely seperate GPIO controllers. Like most peripherals, they are accessed through the <a href=https://en.wikipedia.org/wiki/Advanced_Microcontroller_Bus_Architecture>AHB bus</a>. Each of these peripheral controllers has a set of registers that control the behaviour of the actual peripheral, and each of these registers is wired to the bus. Additionally, although not specified in the block diagram, the CH32V003 core has a system tick counter which we can use to time the GPIO actions. Like the peripherals on the AHB bus, it has a set of registers that control its behaviour.</p><p>This is what&rsquo;s called <a href=https://en.wikipedia.org/wiki/Memory-mapped_I/O_and_port-mapped_I/O>Memory Mapped IO</a>, and it is very common in microcontrollers. The registers from the peripheral controllers are each assigned a unique memory address. Therefore, interfacing with each register translates to a read and/or write operation from/to the bus. The CH32V003 has the following memory map:</p><p><img src=/img/ch32v003-memory-map.png alt="CH32V003 memory map"></p><p>Note that FLASH and SRAM are also peripherals and, while they are connected on different buses, are accesed in the same way as any other peripheral. This means that all components are wired in a way such that when the RISC-V2A core selects an address to read/write to, the correct bus and peripheral controller register is enabled and given access to the bus. So to us, the RISC-V2A core programmers, accessing any peripheral is analogous to reading/writing data to memory.</p><p>According to the memory map diagram, the GPIO port D registers are located between addresses <code>0x40011400</code> and <code>0x40011800</code>, and, though not specified, the system tick timer&rsquo;s registers are located in the Core Private Peripherals section (<code>0xe000000</code> to <code>0xe0100000</code>).</p><h2 id=system-clock-setup>System clock setup</h2><p>Before setting anything else up we should initialize the system clock. After reset, the CH32V003 uses the HSI (High Speed Internal) oscillator at 24MHz as a clock source. The <a href=https://en.wikipedia.org/wiki/Phase-locked_loop>PLL (Phase Locked Loop)</a>, used to multiply the input clock source, is disabled. An <code>HSE</code> (High Speed Extenal) oscillator 4-25MHz can also be used as a clock source which is disabled after reset; up to de user to set it up on every startup.</p><p>The following block diagram shows the system clock tree:</p><p><img src=/img/ch32v003-clock-tree.png alt="CH32V003 clock tree block diagram"></p><p>A few important notes about the clock tree that we should care about:</p><ul><li><code>HSE</code> and <code>HSI</code> can multiplied by 2 through a <code>PLL</code>, so <code>SYSCLK</code> output is multiplexed between <code>HSI</code>, <code>HSE</code>, <code>HSI*2</code> and <code>HSE*2</code></li><li><code>HCLK</code> is prescaled (divisible by: 1, 2, &mldr;, 256) from <code>SYSCLK</code></li><li><code>HCLK</code> is used for HB peripherals (GPIO)</li><li><code>HCLK</code> is used for Core System Timer and can be divided by 8 (useful for longer timer delays)</li></ul><p>Because <code>HCLK</code> depends on <code>SYSCLK</code>, let&rsquo;s configure <code>SYSCLK</code> first. We&rsquo;ll configure it at 48MHz; the maximum supported frequency. Because we don&rsquo;t have an external crystal (HSE), we&rsquo;ll use the internal oscillator (<code>HSI</code>) which runs at 24MHz and feed it to the <code>PLL</code> to multiply it by 2 (24MHz * 2 = 48MHz). So first of all, we have to enable both <code>HSI</code> and <code>PLL</code> and configure <code>HSI</code> as <code>PLL</code> source. Then, because we&rsquo;ll need to kwow when <code>PLL</code> is ready before we can actually select it as a clock source, we should clear RCC interrupt flags. These flags indicate the state of different clock devices and are used to detect when different events happen, and <code>PLL</code> being ready is one of them. Because these flags don&rsquo;t auto-reset we have to reset them so that we can detect when <code>PLL</code> is ready. The next obvious step to finish <code>SYSCLK</code> configuration would be to select <code>HSI</code>+<code>PLL</code> (<code>HSI*2</code>) by selecting <code>PLL</code> as clock source, but before we do that we should configure everything that depends on <code>SYSCLK</code> so that when we do enable it everything else is setup and ready to go. For our use case there are two things to configure: <code>HCLK</code> prescaler configuration (we want to turn it off so that <code>HCLK</code> = <code>SYSCLK</code> = 48MHz) and flash with a 1 cycle latency (this is recommended in the reference manual when 24MHz &lt;= <code>SYSCLK</code> &lt;= 48MHz). The last thing to do is to wait for the <code>PLL</code> to be ready, select it as <code>SYSCLK</code> source and wait until it is actually used as <code>SYSCLK</code> before executing the rest of the program.</p><p>Because some of the steps detailed above can be perfomed at the same time we can optimise the list of steps to look like this:</p><ol><li><a href=#enable-hsi-and-pll>Enable HSI and PLL</a></li><li><a href=#select-hsi-as-pll-source-and-turn-off-prescaler>Select HSI as PLL source and turn off prescaler</a></li><li><a href=#clear-rcc-interrupt-flags>Clear RCC interrupt flags</a></li><li><a href=#configure-flash-to-use-1-cycle-latency>Configure flash to use 1 cycle latency</a></li><li><a href=#wait-until-pll-is-ready>Wait until PLL is ready</a></li><li><a href=#select-pll-as-sysclk>Select PLL as SYSCLK</a></li><li><a href=#wait-until-pll-is-used-as-sysclk>Wait until PLL is used as SYSCLK</a></li></ol><p>All of these steps are performed using the RCC (Reset and Clock Control) registers, with base address <code>0x40021000</code>:</p><p><img src=/img/ch32v003-rcc-registers.png alt="CH32V003 RCC registers"></p><p>and the FLASH registers, with base address <code>0x40022000</code>:</p><p><img src=/img/ch32v003-flash-registers.png alt="CH32V003 FLASH registers"></p><p>More specifically, we&rsquo;ll need the following registers:</p><p><strong>R32_RCC_CTLR</strong>
<img src=/img/ch32v003-rcc-ctlr.png alt="CH32V003 R32_RCC_CTLR"></p><p><strong>R32_RCC_CFGR0</strong>
<img src=/img/ch32v003-rcc-cfgr0.png alt="CH32V003 R32_RCC_CFGR0"></p><p><strong>R32_RCC_INTR</strong>
<img src=/img/ch32v003-rcc-intr.png alt="CH32V003 R32_RCC_INTR"></p><p><strong>R32_FLASH_ACTLR</strong>
<img src=/img/ch32v003-flash-actlr.png alt="CH32V003 R32_FLASH_INTR"></p><p><strong>Note</strong>: the description of each field for all registers is left out for brevity. More information can be found in the <a href=https://www.wch-ic.com/downloads/CH32V003RM_PDF.html>reference manual</a>.</p><h3 id=enable-hsi-and-pll>Enable HSI and PLL</h3><p><code>HSI</code> and <code>PLL</code> are enabled through <code>R32_RCC_CTLR</code> field <code>HSION</code> (bit 0) and field <code>PLLON</code> (bit 24). For both fields, writing a 1 will enable the device and writing a 0 will disable it. So let&rsquo;s write some RISC-V assembly code that enables them both:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#57c7ff>.equ</span> <span style=color:#ff9f43>rcc_base</span>, <span style=color:#ff9f43>0x40021000</span>
</span></span><span style=display:flex><span><span style=color:#57c7ff>.equ</span> <span style=color:#ff9f43>flash_r_base</span>, <span style=color:#ff9f43>0x40022000</span>
</span></span><span style=display:flex><span><span style=color:#57c7ff>.equ</span> <span style=color:#ff9f43>gpio_pd_base</span>, <span style=color:#ff9f43>0x40011400</span>
</span></span><span style=display:flex><span><span style=color:#57c7ff>.equ</span> <span style=color:#ff9f43>systck_base</span>, <span style=color:#ff9f43>0xe000f000</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#57c7ff>.equ</span> <span style=color:#ff9f43>led_pin</span>, <span style=color:#ff9f43>4</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#57c7ff>.globl</span> <span style=color:#ff9f43>main</span>
</span></span><span style=display:flex><span><span style=color:#ff5c57>main:</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>a0</span>, <span style=color:#ff9f43>rcc_base</span> <span style=color:#78787e># a0 -&gt; RCC register base address
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>a1</span>, <span style=color:#ff9f43>flash_r_base</span> <span style=color:#78787e># a1 -&gt; FLASH register base address
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>a2</span>, <span style=color:#ff9f43>gpio_pd_base</span> <span style=color:#78787e># a2 -&gt; GPIO port d register base address
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># PLL_ON (bit 0): enable PLL
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># HSI_ON (bit 24): enable HSI
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     RCC CTLR = 1 &lt;&lt; 0 | 1 &lt;&lt; 24
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     RCC CTLR = 0x01000001
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0x01000001</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>a0</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>a0</span>, <span style=color:#ff9f43>rcc_base</span> <span style=color:#78787e># a0 -&gt; RCC register base address
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>a1</span>, <span style=color:#ff9f43>flash_r_base</span> <span style=color:#78787e># a1 -&gt; FLASH register base address
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>a2</span>, <span style=color:#ff9f43>gpio_pd_base</span> <span style=color:#78787e># a2 -&gt; GPIO port d register base address
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># PLL_ON (bit 0): enable PLL
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># HSI_ON (bit 24): enable HSI
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     RCC CTLR = 1 &lt;&lt; 0 | 1 &lt;&lt; 24
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     RCC CTLR = 0x01000001
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0x01000001</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>a0</span>)
</span></span></code></pre></div><p><strong>Note:</strong> a few lines of code have been added, like constant definitions, which will be needed later.</p><h3 id=select-hsi-as-pll-source-and-turn-off-prescaler>Select HSI as PLL source and turn off prescaler</h3><p>The prescaler is turned off by writing 0 to <code>R32_RCC_CFGR0</code> field <code>HPRE</code> (bits 4-7) and <code>HSI</code> is selected as <code>PLL</code> source by writing 0 to field <code>PLLSRC</code> (bit 16):</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>        <span style=color:#78787e># HPRE = 0: prescaler off; do not divide SYSCLK
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># PLLSRC = 0: HSI (instead of HSE) for PLL input
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     RCC_CFGR0 = 0 &lt;&lt; 4 | 0 &lt;&lt; 16
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     RCC_CFGR0 = 0
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0x00000000</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>4</span>(<span style=color:#ff9f43>a0</span>)
</span></span></code></pre></div><h3 id=clear-rcc-interrupt-flags>Clear RCC interrupt flags</h3><p>Clearing the RCC interrupt flags, actually involves all <code>R32_RCC_INTR</code> fields, so let&rsquo;s take a closer look at them to better understand how this register works:</p><table><thead><tr><th>bit</th><th>name</th><th>access</th><th>description</th></tr></thead><tbody><tr><td>0</td><td><code>LSIRDYF</code></td><td>RO</td><td><code>LSI</code> clock-ready interrupt flag</td></tr><tr><td>2</td><td><code>HSIRDYF</code></td><td>RO</td><td><code>HSI</code> clock-ready interrupt flag</td></tr><tr><td>3</td><td><code>HSERDYF</code></td><td>RO</td><td><code>HSE</code> clock-ready interrupt flag</td></tr><tr><td>4</td><td><code>PLLRDYF</code></td><td>RO</td><td><code>PLL</code> clock-ready lockout interrupt flag</td></tr><tr><td>7</td><td><code>CSSF</code></td><td>RO</td><td>Clock security system interrupt flag bit</td></tr><tr><td>8</td><td><code>LSIRDYIE</code></td><td>RW</td><td><code>LSI</code> ready interrupt enable bit</td></tr><tr><td>10</td><td><code>HSIRDYIE</code></td><td>RW</td><td><code>HSI</code> ready interrupt enable bit</td></tr><tr><td>11</td><td><code>HSERDYIE</code></td><td>RW</td><td><code>HSE</code> ready interrupt enable bit</td></tr><tr><td>12</td><td><code>PLLRDYIE</code></td><td>RW</td><td><code>PLL</code> ready interrupt enable bit</td></tr><tr><td>16</td><td><code>LSIRDYC</code></td><td>WO</td><td>Clear the <code>LSI</code> oscillator ready interrupt flag bit</td></tr><tr><td>19</td><td><code>HSERDYC</code></td><td>WO</td><td>Clear the <code>HSE</code> oscillator ready interrupt flag bit</td></tr><tr><td>18</td><td><code>HSIRDYC</code></td><td>WO</td><td>Clear the <code>HSI</code> oscillator ready interrupt flag bit</td></tr><tr><td>20</td><td><code>PLLRDYC</code></td><td>WO</td><td>Clear the <code>PLL</code> ready interrupt flag bit</td></tr><tr><td>23</td><td><code>CSSC</code></td><td>WO</td><td>Clear the clock security system interrupt flag bit</td></tr></tbody></table><p>The first 5 table entries are interrupt flags, indicated by the trailing <code>F</code>, and are read-only because they are set by hardware. The last 5 table entries are fields used to clear the interrupt flags, indicated by the trailing <code>C</code>, and are write-only. Because the interrupt flags are set by hardware, these fields are needed to physically &ldquo;reset&rdquo; the corresponding hardware, which will in turn clear the corresponding interrupt flag. Finally, the middle 4 table entries are interrupt enable fields, indicated by the trailing <code>IE</code>. When set to 1 an interrupt will be generated when the corresponding interrupt flag is set.</p><p>For our use case, we actually only <em>need</em> to clear certain interrupt flags in order to know when certain events happend (e.g. we&rsquo;ll need to know when <code>PLL</code> is ready after we have enabled it), but clearing all of the interrupt flags is a good idea when changing the clock tree configuration anyway, so we&rsquo;ll do that. Also, we could write our program in a way that doesn&rsquo;t actively wait for the peripherals to be ready by utilizing interrupts but that would complicate our code, so we&rsquo;ll disable interrupts too:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>        <span style=color:#78787e># CSSC     (bit 23) = 1 -&gt; clear CSSF (clock security system interrupt flag bit)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># PLLRDYC  (bit 20) = 1 -&gt; clear PLLRDYF (PLL-ready interrupt flag bit)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># HSERDYC  (bit 19) = 1 -&gt; clear HSERDYF (HSE oscillator ready interrupt flag bit)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># HSIRDYC  (bit 18) = 1 -&gt; clear HSIRDYF (HSI oscillator ready interrupt flag bit)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># LSIRDYC  (bit 16) = 1 -&gt; clear LSIRDYF (LSI oscillator ready interrupt flag bit)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># PLLRDYIE (bit 12) = 0 -&gt; disable PLL-ready interrupt
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># HSERDYIE (bit 11) = 0 -&gt; disable HSE-ready interrupt
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># HSIRDYIE (bit 10) = 0 -&gt; disable HSI-ready interrupt
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># LSIRDYIE (bit  8) = 0 -&gt; disable LSI-ready interrupt
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     RCC_INTR = 1&lt;&lt;23 | 1&lt;&lt;20 | 1&lt;&lt;19 | 1&lt;&lt;18 | 1&lt;&lt;16 | 0&lt;&lt;12 | 0&lt;&lt;11 | 0&lt;&lt;10 | 0&lt;&lt;8
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     RCC_INTR = 0b 0000 0000 1001 1101 0000 0000 0000 0000
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     RCC_INTR = 0x009d0000
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0x009d0000</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>8</span>(<span style=color:#ff9f43>a0</span>)
</span></span></code></pre></div><h3 id=configure-flash-to-use-1-cycle-latency>Configure flash to use 1 cycle latency</h3><p>Flash latency is configured through <code>R32_FLASH_ACTLR</code> field <code>LATENCY</code> (bits 0-1); writing a 1 will select a 1 cycle latency:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>        <span style=color:#78787e># configure flash to recommended settings for 48MHz clock
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># LATENCY (bits 0-1) = 1
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     FLASH_ACTLR = 1 &lt;&lt; 0
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     FLASH_ACTLR = 1
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0x00000001</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>a1</span>)
</span></span></code></pre></div><h3 id=wait-until-pll-is-ready>Wait until PLL is ready</h3><p>When <code>PLL</code> is ready <code>RCC_CTLR</code> field <code>PLLRDY</code> (bit 25) will be set to 1. So we could write a loop that iterates until <code>PLLRDY</code> is set:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>        <span style=color:#78787e># wait until PLL is ready
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>t1</span>, <span style=color:#ff9f43>0x02000000</span> <span style=color:#78787e># PLL_RDY mask = 1 &lt;&lt; 25
</span></span></span><span style=display:flex><span><span style=color:#78787e></span><span style=color:#ff5c57>.L_pll_rdy_wait:</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>a0</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>and</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t1</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>beq</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>zero</span>, <span style=color:#ff9f43>.L_pll_rdy_wait</span>
</span></span></code></pre></div><h3 id=select-pll-as-sysclk>Select PLL as SYSCLK</h3><p>Once <code>PLL</code> is ready we can select it as <code>SYSCLK</code> source, which is done by setting <code>R32_RCC_CFGR0</code> field <code>SW</code> (bits 0-1) to 2. Because we don&rsquo;t want to modify the rest of the fields we could read the register value, set the first two bits to 0 with a bitwise AND mask (which would be <code>0b11 &lt;&lt; 0 = 0x00000003</code>) and then bitwise OR the result with 2:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>        <span style=color:#78787e># RCC_CFGR0 = RCC_CFGR0 &amp; ~(0b11) | 0b10
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># RCC_CFGR0 = RCC_CFGR0 &amp; ~(0x00000003) | 0x00000002
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># RCC_CFGR0 = RCC_CFGR0 &amp; 0xfffffffc | 0x00000002
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>4</span>(<span style=color:#ff9f43>a0</span>) <span style=color:#78787e># t0 = RCC_CFGR0
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>and</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0xfffffffc</span> <span style=color:#78787e># clear clock source selection ~(0x00000003) = 0xfffffffc
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>or</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0x00000002</span> <span style=color:#78787e># select PLL as clock source 0x00000002
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>4</span>(<span style=color:#ff9f43>a0</span>)
</span></span></code></pre></div><h3 id=wait-until-pll-is-used-as-sysclk>Wait until PLL is used as SYSCLK</h3><p>When <code>PLL</code> is selected as clock source <code>R32_RCC_CFGR0</code> field <code>SWS</code> (bits 2-3) will be set to 2 (the same value we set field <code>SW</code> to in the previous step). We could write a loop that iterates until <code>SWS</code> is set to 2:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>        <span style=color:#78787e># wait until PLL is used as SYSCLK
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>t1</span>, <span style=color:#ff9f43>0x0000000c</span> <span style=color:#78787e># RCC_CFGR0 SWS mask
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>t2</span>, <span style=color:#ff9f43>0x00000008</span> <span style=color:#78787e># RCC_CFGR0 SW PLL
</span></span></span><span style=display:flex><span><span style=color:#78787e></span><span style=color:#ff5c57>.L_pll_use_wait:</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>4</span>(<span style=color:#ff9f43>a0</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>and</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t1</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>bne</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t2</span>, <span style=color:#ff9f43>.L_pll_use_wait</span>
</span></span></code></pre></div><h2 id=gpio-port-setup>GPIO port setup</h2><p>Before we can set a pin high or low we have to enable the corresponding GPIO port and configure the individual pin as output.</p><p>Enabling the GPIO port is done through <code>R32_RCC_APB2PCENR</code> field <code>IOPDEN</code> (bit 5) which enables (when set to 1) disables (when set to 0) GPIO port D clock:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>        <span style=color:#78787e># setup GPIO pin for led
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># enable GPIO port D clock
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># RCC_AP2PCENR = RCC_AP2PCENR | 1 &lt;&lt; 5
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># RCC_AP2PCENR = RCC_AP2PCENR | 0x00000020
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>24</span>(<span style=color:#ff9f43>a0</span>) <span style=color:#78787e># t0 = APB2PCENR
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>or</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0x00000020</span> <span style=color:#78787e># APB2PCENR | EPB2PCENR_IOPDEN
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>24</span>(<span style=color:#ff9f43>a0</span>)
</span></span></code></pre></div><p>Configuring the GPIO pin involves the GPIO registers, where each port has a different base address:</p><p><img src=/img/ch32v003-gpio-registers.png alt="CH32V003 GPIO registers"></p><p><strong>Note</strong>: <code>R32_GPIOX_CFGLR</code> address and the next register address, <code>R32_GPIOX_INDR</code>, have an 8 byte difference. Since each register occupies 4 bytes that means there&rsquo;s a reserved register between them. On other chips of the CH32 family this space is used for <code>R32_GPIOX_CFGHR</code> (Configuration High Register) which controls another 8 pins, doubling the amount of pins for each GPIO port. Even though this register is not present in the CH32V003 it is left blank to maintain register address consistency within the chip family.</p><p>More specifically, the <code>R32_GPIOX_CFGLR</code> (Configuration Low Register) is used to configure GPIO port D pins 0-7:</p><p><img src=/img/ch32v003-gpio-cfglr.png alt="CH32V003 GPIO CFGLR"></p><p>So, if we want to configure pin 4 we have to write to fields <code>MODE4</code> (bits 16-17) and <code>CNF4</code> (bits 18-19). To control the LED we want to set <code>MODE4</code> to 1, which indicates output at 10MHz maximum speed, and <code>CNF4</code> to 0, which indicates push-pull output mode. Because we don&rsquo;t want to overwrite the rest of pin configurations we could first perform a bitwise AND with a mask to clear the previous configuration and then bitwise OR the result with the new configuration:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>        <span style=color:#78787e># clear current pin config with an and mask (shift count determined by pin number * pin conf bit count -&gt; pin*4)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># GPIOD_CFGLR = GPIOD_CFGLR &amp; ~(0xf &lt;&lt; (4*pin)) | ((0|1) &lt;&lt; (4*pin))
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>a2</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>t1</span>, <span style=color:#ff5c57>~</span>(<span style=color:#ff9f43>0x0f</span> <span style=color:#ff5c57>&lt;&lt;</span> (<span style=color:#ff9f43>4</span> * <span style=color:#ff9f43>led_pin</span>))
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>and</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>t1</span>, <span style=color:#ff9f43>0x00000001</span> <span style=color:#ff5c57>&lt;&lt;</span> (<span style=color:#ff9f43>4</span> * <span style=color:#ff9f43>led_pin</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>or</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t1</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>a2</span>)
</span></span></code></pre></div><h2 id=system-tick-counter-as-timer>System tick counter as timer</h2><p>The system counter is a device that increments a register value on every clock cycle. It has a special register that allows us to set a comparison value so that when the counter value exceeds the comparison value a flag is set. We can use this to time actions in terms of clock cycles. These are its registers:</p><p><img src=/img/ch32v003-stk-registers.png alt="CH32V003 STK registers"></p><p><code>R32_STK_CTLR</code> is used to control the system counter:</p><p><img src=/img/ch32v003-stk-ctlr.png alt="CH32V003 STK CTLR"></p><p>The fields <code>SWIE</code> (software interrupt trigger enable) and <code>STIE</code> (counter interrupt enable) are both used to enable/disabled interrupts. Because we won&rsquo;t be using interrupts we&rsquo;ll set them both to 0.</p><p>Field <code>STRE</code> (System Tick auto-Reload Enable) is used to configure whether the counter resets to 0 after the comparison values has been reached or if it continues counting up to the maximum value. We don&rsquo;t really care about this as we&rsquo;ll stop the counter as soon as we detect the comparison value has been reached.</p><p>Field <code>STCLK</code> (system tick clock source) is used to select the counter clock source: <code>HCLK</code> (when set to 1) or <code>HCLK/8</code> (when set to 0). It doesn&rsquo;t really matter which setting we use as long as we take it into consideration when calculating the amount of ticks to set the counter to. We&rsquo;ll use <code>HCLK/8</code> as clock source as it allows for longer time delays.</p><p>Field <code>STE</code> (system tick enable) is used to turn on the counter (when set to 1) or turn it off (when set to 0).</p><p><code>R32_STK_SR</code> has a single 1-bit field, <code>CNTIF</code>, which is set to 1 when the counter reaches the comparison value:</p><p><img src=/img/ch32v003-stk-sr.png alt="CH32V003 STK CTLR"></p><p><code>R32_STK_CNTL</code> has a single 32-bit field, <code>CNT</code>, which holds the current counter value:</p><p><img src=/img/ch32v003-stk-cntl.png alt="CH32V003 STK CTLR"></p><p><code>R32_STK_CMPLR</code> has a single 32-bit field, <code>CMP</code>, which holds the comparison value:</p><p><img src=/img/ch32v003-stk-cmplr.png alt="CH32V003 STK CTLR"></p><p>Given this set of registers, implementing a system tick delay function is reasonably simple:</p><ol><li>Turn system tick counter off and set clock source as <code>HCLK/8</code></li><li>Clear the comparison flag</li><li>Set initial counter value</li><li>Set comparison counter value</li><li>Turn system tick counter on</li><li>Wait until the comparison flag is set</li><li>Turn system tick counter off</li></ol><p>Let&rsquo;s write a function waits until the number of ticks (<code>HCLK/8</code>) in register <code>a0</code> have been reached:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#ff5c57>delay_systick:</span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># function prologue
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>addi</span> <span style=color:#ff9f43>sp</span>, <span style=color:#ff9f43>sp</span>, -<span style=color:#ff9f43>16</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>ra</span>, <span style=color:#ff9f43>12</span>(<span style=color:#ff9f43>sp</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>8</span>(<span style=color:#ff9f43>sp</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>s1</span>, <span style=color:#ff9f43>4</span>(<span style=color:#ff9f43>sp</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>s1</span>, <span style=color:#ff9f43>systck_base</span> <span style=color:#78787e># s1 -&gt; system tick register base address
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># stop system counter (set STE [bit 0] to 0) and select HCLK/8 as clock source (set STCLK [bit 2] to 0)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_CTLR = STK_CTLR &amp; ~((1&lt;&lt;0) | (1&lt;&lt;2))
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_CTLR = STK_CTLR &amp; ~(0x00000005)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_CTLR = STK_CTLR &amp; ~(0x00000005)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_CTLR = STK_CTLR &amp; 0xfffffffa
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>s1</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>and</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>0xfffffffa</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>s1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># clear count value comparison flag (set CNTIF [bit 0] to 0)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_SR = STK_SR &amp; ~(1&lt;&lt;0)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_SR = STK_SR &amp; 0xfffffffe
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>0xfffffffe</span> <span style=color:#78787e># s0 = ~(1)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>4</span>(<span style=color:#ff9f43>s1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># set initial counter value
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_CNTL = 0
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>zero</span>, <span style=color:#ff9f43>8</span>(<span style=color:#ff9f43>s1</span>)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#78787e># set count end value
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_CMPLR = a0
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>a0</span>, <span style=color:#ff9f43>16</span>(<span style=color:#ff9f43>s1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># start system counter (set STE [bit 0] to 1)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_CTLR = STK_CTLR | (1&lt;&lt;0)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_CTLR = STK_CTLR | 0x00000001
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>s1</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>or</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>0x00000001</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>s1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># wait until count system counter has reached target number
</span></span></span><span style=display:flex><span><span style=color:#78787e></span><span style=color:#ff5c57>.L_wait:</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>4</span>(<span style=color:#ff9f43>s1</span>) <span style=color:#78787e># s0 = STK_SR
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>and</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>0x00000001</span> <span style=color:#78787e># s0 = STK_SR &amp; 0x00000001
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>beq</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>zero</span>, <span style=color:#ff9f43>.L_wait</span> <span style=color:#78787e># if s0 != 0 -&gt; bit 0 is set -&gt; count has been reached
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># stop system counter (set STE [bit 0] to 0)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_CTLR = STK_CTLR &amp; ~(1&lt;&lt;0)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_CTLR = STK_CTLR &amp; 0xfffffffe
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>s1</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>and</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>0xfffffffe</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>s1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># function epilogue
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>s1</span>, <span style=color:#ff9f43>4</span>(<span style=color:#ff9f43>sp</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>8</span>(<span style=color:#ff9f43>sp</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>ra</span>, <span style=color:#ff9f43>12</span>(<span style=color:#ff9f43>sp</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>addi</span> <span style=color:#ff9f43>sp</span>, <span style=color:#ff9f43>sp</span>, <span style=color:#ff9f43>16</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>ret</span>
</span></span></code></pre></div><h2 id=making-the-led-blink>Making the LED blink</h2><p>Now all that remains is to actually make the LED blink by setting GPIO D4 high and low in between <code>delay_systick</code> calls. There are two registers we can use to set any given GPIO pin high or low.</p><p><code>R32_GPIOX_BCR</code> is only used to reset (set to low state) any pin in the GPIO port by writing a 1 to the corresponding field:</p><p><img src=/img/ch32v003-gpio-bcr.png alt="CH32V003 GPIO BCR"></p><p><code>R32_GPIOX_BSHR</code> is used for both setting (set to high state) and resetting (set to low state) any given pin in the GPIO port. Works identically to <code>R32_GPIOX_BCR</code> but the set fields are on the lower 16 bits and the reset fields are on the higher 16 bits. This register is useful for setting and resetting different pins at the same time and in scenarios where immediate execution of the next instruction is not guaranteed (when interrupts are enabled or on multicore CPUs) because it can be done in a single <em>atomic</em> operation.</p><p><img src=/img/ch32v003-gpio-bshr.png alt="CH32V003 GPIO BSHR"></p><p>Because we want to have the LED on and off for a certain amount of time we have to convert that amount to number of system ticks in order to use the <code>delay_systick</code> function. For a 48MHz system clock source we could calculate the milisecond to tick factor the following way:</p><p>$$
\frac{48000000cycle}{1s} \cdot \frac{1tick}{8cycle} \cdot \frac{1s}{1000ms} = 6000 ticks/ms
$$</p><p>Finally, we can write an infinite loop to blink the LED:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>t2</span>, <span style=color:#ff9f43>1</span> <span style=color:#ff5c57>&lt;&lt;</span> <span style=color:#ff9f43>led_pin</span> <span style=color:#78787e># pin mask
</span></span></span><span style=display:flex><span><span style=color:#78787e></span><span style=color:#ff5c57>.L_loop:</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>t2</span>, <span style=color:#ff9f43>20</span>(<span style=color:#ff9f43>a2</span>) <span style=color:#78787e># GPIO_BCR = (1 &lt;&lt; led_pin)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>a0</span>, <span style=color:#ff9f43>100</span>*<span style=color:#ff9f43>ms_to_tick</span> <span style=color:#78787e># keep led on for 100ms
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>call</span> <span style=color:#ff9f43>delay_systick</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>t2</span>, <span style=color:#ff9f43>16</span>(<span style=color:#ff9f43>a2</span>) <span style=color:#78787e># GPIO_BSHR = (1 &lt;&lt; led_pin)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>a0</span>, <span style=color:#ff9f43>1000</span>*<span style=color:#ff9f43>ms_to_tick</span> <span style=color:#78787e># keep led off for 1000ms
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>call</span> <span style=color:#ff9f43>delay_systick</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>j</span> <span style=color:#ff9f43>.L_loop</span>
</span></span></code></pre></div><p>And if we put it all together:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#57c7ff>.section</span> <span style=color:#ff9f43>.text</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#57c7ff>.equ</span> <span style=color:#ff9f43>ms_to_tick</span>, <span style=color:#ff9f43>48000000</span><span style=color:#ff5c57>/</span><span style=color:#ff9f43>8000</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#57c7ff>.equ</span> <span style=color:#ff9f43>rcc_base</span>, <span style=color:#ff9f43>0x40021000</span>
</span></span><span style=display:flex><span><span style=color:#57c7ff>.equ</span> <span style=color:#ff9f43>flash_r_base</span>, <span style=color:#ff9f43>0x40022000</span>
</span></span><span style=display:flex><span><span style=color:#57c7ff>.equ</span> <span style=color:#ff9f43>gpio_pd_base</span>, <span style=color:#ff9f43>0x40011400</span>
</span></span><span style=display:flex><span><span style=color:#57c7ff>.equ</span> <span style=color:#ff9f43>systck_base</span>, <span style=color:#ff9f43>0xe000f000</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#57c7ff>.equ</span> <span style=color:#ff9f43>led_pin</span>, <span style=color:#ff9f43>4</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#57c7ff>.globl</span> <span style=color:#ff9f43>main</span>
</span></span><span style=display:flex><span><span style=color:#ff5c57>main:</span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># setup clock to 48MHz
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>a0</span>, <span style=color:#ff9f43>rcc_base</span> <span style=color:#78787e># a0 -&gt; RCC register base address
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>a1</span>, <span style=color:#ff9f43>flash_r_base</span> <span style=color:#78787e># a1 -&gt; FLASH register base address
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>a2</span>, <span style=color:#ff9f43>gpio_pd_base</span> <span style=color:#78787e># a2 -&gt; GPIO port d register base address
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># PLL_ON (bit 0): enable PLL
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># HSI_ON (bit 24): enable HSI
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     RCC_CTLR = 1 &lt;&lt; 0 | 1 &lt;&lt; 24
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     RCC_CTLR = 0x01000001
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0x01000001</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>a0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># HPRE = 0: prescaler off; do not divide SYSCLK
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># PLLSRC = 0: HSI (instead of HSE) for PLL input
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     RCC_CFGR0 = 0 &lt;&lt; 4 | 0 &lt;&lt; 16
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     RCC_CFGR0 = 0
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0x00000000</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>4</span>(<span style=color:#ff9f43>a0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># configure flash to recommended settings for 48MHz clock
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># LATENCY (bits 0-1) = 1
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     FLASH_ACTLR = 1 &lt;&lt; 0
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     FLASH_ACTLR = 1
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0x00000001</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>a1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># CSSC     (bit 23) = 1 -&gt; clear CSSF (clock security system interrupt flag bit)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># PLLRDYC  (bit 20) = 1 -&gt; clear PLLRDYF (PLL-ready interrupt flag bit)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># HSERDYC  (bit 19) = 1 -&gt; clear HSERDYF (HSE oscillator ready interrupt flag bit)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># HSIRDYC  (bit 18) = 1 -&gt; clear HSIRDYF (HSI oscillator ready interrupt flag bit)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># LSIRDYC  (bit 16) = 1 -&gt; clear LSIRDYF (LSI oscillator ready interrupt flag bit)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># PLLRDYIE (bit 12) = 0 -&gt; disable PLL-ready interrupt
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># HSERDYIE (bit 11) = 0 -&gt; disable HSE-ready interrupt
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># HSIRDYIE (bit 10) = 0 -&gt; disable HSI-ready interrupt
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># LSIRDYIE (bit  8) = 0 -&gt; disable LSI-ready interrupt
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     RCC_INTR = 1&lt;&lt;23 | 1&lt;&lt;20 | 1&lt;&lt;19 | 1&lt;&lt;18 | 1&lt;&lt;16 | 0&lt;&lt;12 | 0&lt;&lt;11 | 0&lt;&lt;10 | 0&lt;&lt;8
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     RCC_INTR = 0b 0000 0000 1001 1101 0000 0000 0000 0000
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     RCC_INTR = 0x009d0000
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0x009d0000</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>8</span>(<span style=color:#ff9f43>a0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># wait until PLL is ready
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>t1</span>, <span style=color:#ff9f43>0x02000000</span> <span style=color:#78787e># PLL_RDY mask
</span></span></span><span style=display:flex><span><span style=color:#78787e></span><span style=color:#ff5c57>.L_pll_rdy_wait:</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>a0</span>) <span style=color:#78787e># RCC CTLR
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>and</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t1</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>beq</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>zero</span>, <span style=color:#ff9f43>.L_pll_rdy_wait</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># RCC_CFGR0 = RCC_CFGR0 &amp; ~(0b11) | 0b10
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># RCC_CFGR0 = RCC_CFGR0 &amp; ~(0x00000003) | 0x00000002
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># RCC_CFGR0 = RCC_CFGR0 &amp; 0xfffffffc | 0x00000002
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>4</span>(<span style=color:#ff9f43>a0</span>) <span style=color:#78787e># t0 = RCC CFGR0
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>and</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0xfffffffc</span> <span style=color:#78787e># ~(RCC CFGR0 SW) = ~(0x00000003) = 0xfffffffc
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>or</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0x00000002</span> <span style=color:#78787e># RCC CFGR0 SW PLL = 0x00000002
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>4</span>(<span style=color:#ff9f43>a0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># wait until PLL is used as SYSCLK
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>t1</span>, <span style=color:#ff9f43>0x0000000c</span> <span style=color:#78787e># RCC CFGR0 SWS mask
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>t2</span>, <span style=color:#ff9f43>0x00000008</span> <span style=color:#78787e># RCC CFGR0 SW PLL
</span></span></span><span style=display:flex><span><span style=color:#78787e></span><span style=color:#ff5c57>.L_pll_use_wait:</span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># RCC CFGR0
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>4</span>(<span style=color:#ff9f43>a0</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>and</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t1</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>bne</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t2</span>, <span style=color:#ff9f43>.L_pll_use_wait</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># setup GPIO pin for led
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># enable GPIO port D
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>24</span>(<span style=color:#ff9f43>a0</span>) <span style=color:#78787e># t0 = APB2PCENR
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>or</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0x00000020</span> <span style=color:#78787e># APB2PCENR | EPB2PCENR_IOPDEN
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>24</span>(<span style=color:#ff9f43>a0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># clear current pin config with an and mask (shift count determined by pin number * pin conf bit count -&gt; pin*4)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># GPIOD_CFGLR = GPIOD_CFGLR &amp; ~(0xf &lt;&lt; (4*pin))
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>a2</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>t1</span>, <span style=color:#ff5c57>~</span>(<span style=color:#ff9f43>0x0f</span> <span style=color:#ff5c57>&lt;&lt;</span> (<span style=color:#ff9f43>4</span> * <span style=color:#ff9f43>led_pin</span>))
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>and</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># set new pin config with an or
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># GPIOD_CFGLR = GPIOD_CFGLR | ((0|1) &lt;&lt; (4*pin))
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>t1</span>, <span style=color:#ff9f43>0x00000001</span> <span style=color:#ff5c57>&lt;&lt;</span> (<span style=color:#ff9f43>4</span> * <span style=color:#ff9f43>led_pin</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>or</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t1</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>a2</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>t2</span>, <span style=color:#ff9f43>1</span> <span style=color:#ff5c57>&lt;&lt;</span> <span style=color:#ff9f43>led_pin</span> <span style=color:#78787e># pin mask
</span></span></span><span style=display:flex><span><span style=color:#78787e></span><span style=color:#ff5c57>.L_loop:</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>t2</span>, <span style=color:#ff9f43>20</span>(<span style=color:#ff9f43>a2</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>a0</span>, <span style=color:#ff9f43>100</span>*<span style=color:#ff9f43>ms_to_tick</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>call</span> <span style=color:#ff9f43>delay_systick</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>t2</span>, <span style=color:#ff9f43>16</span>(<span style=color:#ff9f43>a2</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>a0</span>, <span style=color:#ff9f43>1000</span>*<span style=color:#ff9f43>ms_to_tick</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>call</span> <span style=color:#ff9f43>delay_systick</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>j</span> <span style=color:#ff9f43>.L_loop</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff5c57>delay_systick:</span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># function prologue
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>addi</span> <span style=color:#ff9f43>sp</span>, <span style=color:#ff9f43>sp</span>, -<span style=color:#ff9f43>16</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>ra</span>, <span style=color:#ff9f43>12</span>(<span style=color:#ff9f43>sp</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>8</span>(<span style=color:#ff9f43>sp</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>s1</span>, <span style=color:#ff9f43>4</span>(<span style=color:#ff9f43>sp</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>s1</span>, <span style=color:#ff9f43>systck_base</span> <span style=color:#78787e># s1 -&gt; system tick register base address
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># stop system counter (set STE [bit 0] to 0) and set HCLK/8 as clock source (set STCLK [bit 2] to 0)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_CTLR = STK_CTLR &amp; ~((1&lt;&lt;0) | (1&lt;&lt;2))
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_CTLR = STK_CTLR &amp; ~(0x00000005)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_CTLR = STK_CTLR &amp; ~(0x00000005)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_CTLR = STK_CTLR &amp; 0xfffffffa
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>s1</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>and</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>0xfffffffa</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>s1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># clear count value comparison flag (set CNTIF [bit 0] to 0)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_SR = STK_SR &amp; ~(1&lt;&lt;0)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_SR = STK_SR &amp; 0xfffffffe
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>0xfffffffe</span> <span style=color:#78787e># s0 = ~(1)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>4</span>(<span style=color:#ff9f43>s1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># set initial counter value
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_CNTL = 0
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>zero</span>, <span style=color:#ff9f43>8</span>(<span style=color:#ff9f43>s1</span>)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#78787e># set count end value
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_CMPLR = a0
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>a0</span>, <span style=color:#ff9f43>16</span>(<span style=color:#ff9f43>s1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># start system counter (set STE [bit 0] to 1)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_CTLR = STK_CTLR | (1&lt;&lt;0)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_CTLR = STK_CTLR | 0x00000001
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>s1</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>or</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>0x00000001</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>s1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># wait until count system counter has reached target number
</span></span></span><span style=display:flex><span><span style=color:#78787e></span><span style=color:#ff5c57>.L_wait:</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>4</span>(<span style=color:#ff9f43>s1</span>) <span style=color:#78787e># s0 = STK_SR
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>and</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>0x00000001</span> <span style=color:#78787e># s0 = STK_SR &amp; 0x00000001
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>beq</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>zero</span>, <span style=color:#ff9f43>.L_wait</span> <span style=color:#78787e># if s0 != 0 -&gt; bit 0 is set -&gt; count has been reached
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># stop system counter (set STE [bit 0] to 0)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_CTLR = STK_CTLR &amp; ~(1&lt;&lt;0)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e># STK_CTLR = STK_CTLR &amp; 0xfffffffe
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>s1</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>and</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>0xfffffffe</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>sw</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>0</span>(<span style=color:#ff9f43>s1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># function epilogue
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>s1</span>, <span style=color:#ff9f43>4</span>(<span style=color:#ff9f43>sp</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>s0</span>, <span style=color:#ff9f43>8</span>(<span style=color:#ff9f43>sp</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>lw</span> <span style=color:#ff9f43>ra</span>, <span style=color:#ff9f43>12</span>(<span style=color:#ff9f43>sp</span>)
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>addi</span> <span style=color:#ff9f43>sp</span>, <span style=color:#ff9f43>sp</span>, <span style=color:#ff9f43>16</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>ret</span>
</span></span></code></pre></div><h2 id=startup-code--linker-script>Startup code & linker script</h2><p>I don&rsquo;t want to go too much into detail in this section as it isn&rsquo;t really the purpose of this post and I risk making incorrect statements as this is my first RISC-V low level &ldquo;deep dive&rdquo;. Nevertheless, I will go through some aspects I consider important.</p><p>This section has been taken almost entirely from the manufacturer&rsquo;s PlatformIO example <a href=https://github.com/Community-PIO-CH32V/ch32-pio-projects/blob/78f044b49b0cb201493ec6254408be459f47dcc5/baremetal-ch32v003/src/startup_ch32v003.c>startup code</a>. I only have simplified and/or expanded upon it.</p><hr><p>Before the microcontroller can jump to the <code>main</code> symbol and execute our code we <em>should</em> setup some stuff. Most notably, because this microcontroller supports interrupts, we should setup the <a href=https://en.wikipedia.org/wiki/Interrupt_vector_table>interrupt vector table</a> so that if an interrupt/exception were to happen it is handled correctly without any unexpected behaviour. To do this, we have four CSR registers:</p><p>The first two are RISC-V standard CSRs and do not appear in the manual (here&rsquo;s a blog I found that documents their layout: <a href=https://five-embeddev.com/riscv-priv-isa-manual/latest-adoc/hypervisor.html#_machine_status_registers_mstatus_and_mstatush>MSTATUS</a>, <a href=https://five-embeddev.com/riscv-priv-isa-manual/latest-adoc/machine.html#_machine_exception_program_counter_mepc>MEPC</a>):</p><p><code>MSTATUS</code> (Machine Status Register) with address <code>0x300</code> which controls the processor&rsquo;s global state, particularly privilege levels and interrupt enables. For our use case, field at bit 3 <code>MIE</code> (Machine Interrupt Enable) which enables interrupts when set to 1 and field at bit 7 <code>MPIE</code> (Machine Previous Interrupt Enable) which holds the previous interrupt enable state (before entering an interrupt/exception handler) and is used to restore the value of <code>MIE</code> when returning from an interrupt handler (with the <code>mret</code> instruction).</p><p><code>MEPC</code> (Machine Exception Program Counter) with address <code>0x341</code> which holds the program counter when an exception or interrupt occurs so that the exception handler can properly return.</p><p>The last two are actually vendor-specific and are listed on the manual. The first one, although it is a <a href=https://five-embeddev.com/riscv-priv-isa-manual/latest-adoc/machine.html#_machine_trap_vector_base_address_register_mtvec>RISC-V standard</a>, has been extended to allow for more configuration options:</p><p><img src=/img/ch32v003-mtvec-register.png alt="CH32V003 MTVEC register"></p><p>Field <code>BASEADDR</code> (bits 2-31) indicates the base address for the interrupt vector. Initially, it points to address <code>0x00000000</code> which is the entry address (the first instruction the microcontroller executes upon reset). Also, notice how the last two bits are not part of this field despite the address space being 32-bit. This is because the interrupt vector address must be 4-byte aligned and the two least significant bits are hardwired to 0.</p><p>Field <code>MODE1</code> (bit 1) selects the interrupt table identification pattern: when set to 1 the microcontroller expects every entry of the interrupt vector to be a jump instruction to the handler, when configured to 0 it expects the absolute address of the handler.</p><p>Field <code>MODE0</code> (bit 0) selects the interrupt entry address mode: when set to 0 all interrupt handlers will have the same handler entry address, when set to 1 each interrupt handler will be offset by the <code>interrupt_number * 4</code> so the address of the handler for interrupt number <code>n</code> will be <code>BASEADDR + n*4</code> with the following layout:</p><p><img src=/img/ch32v003-interrupt-vector.png alt="CH32V003 Interrupt Vector Table"></p><p>The second one, <code>INTSYSCR</code> is a completely custom CSR:</p><p><img src=/img/ch32v003-intsyscr-register.png alt="CH32V003 INTSYSCR register"></p><p>Field <code>INESTEN</code> (bit 1) enables interrupt nesting when set to 1, and disables it when set to 0.</p><p>Field <code>HWSTKEN</code> (bit 0) enables hardware stacking when set to 1, and disables it when set to 0.</p><p>So there are a few configuration options to choose from and because in our case it doesn&rsquo;t really matter what we choose I have chosen the following configuration:</p><ul><li>interrupt nesting and hardware stacking enabled</li><li>interrupt vector with offsets instead of a unified entry address</li><li>interrupt vector with absolute addresses instead of jump instructions</li><li>all interrupt handlers point to function which loops forever</li></ul><p>With this in mind we could write the following entry function, <code>start</code>, which also acts as the reset handler:</p><div class=highlight><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#57c7ff>.section</span> <span style=color:#ff9f43>.init</span>
</span></span><span style=display:flex><span><span style=color:#57c7ff>.globl</span> <span style=color:#ff9f43>start</span>
</span></span><span style=display:flex><span><span style=color:#ff5c57>start:</span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># there isn&#39;t really a need for setting up gp since it isn&#39;t used in this program
</span></span></span><span style=display:flex><span><span style=color:#78787e></span><span style=color:#57c7ff>.option</span> <span style=color:#ff9f43>push</span>
</span></span><span style=display:flex><span><span style=color:#57c7ff>.option</span> <span style=color:#ff9f43>norelax</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>la</span> <span style=color:#ff9f43>gp</span>, <span style=color:#ff9f43>__global_pointer$</span>
</span></span><span style=display:flex><span><span style=color:#57c7ff>.option</span> <span style=color:#ff9f43>pop</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>la</span> <span style=color:#ff9f43>sp</span>, <span style=color:#ff9f43>__stack_end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># set CSR register MSTATUS (Machine Status)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     bit 7: MPIE (Machine Previous Interrupt Enable) to 1, which will enable interrupts when mret is executed
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     bit 3: MIE (Machine Interrupt Enable) to 0, which disables interrupts
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0x80</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>csrw</span> <span style=color:#ff9f43>mstatus</span>, <span style=color:#ff9f43>t0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># set CSR register INTSYSCR (Interrupt System Control Register) located at CSR address 0x804
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     bit 1: interrupt nesting table enable to 1
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     bit 0: hardware stack enable to 1
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>li</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>0x3</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>csrw</span> <span style=color:#ff9f43>0x804</span>, <span style=color:#ff9f43>t0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># set CSR register MTVEC (Exception Entry Base Address Register)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     bits [31:2]: interrupt vector table base address (aligned to 4 bytes; last two bits are hardwired to 0)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     bit 1: indentify pattern -&gt; 1 : by absolute address
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     bit 0: entry address -&gt; 1 : address offset based on interrupt number*4
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>la</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>isr_vector</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>ori</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>3</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>csrw</span> <span style=color:#ff9f43>mtvec</span>, <span style=color:#ff9f43>t0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># set CSR register MEPC (Machine Exception Program Counter); return address of an exception handler
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#57c7ff>la</span> <span style=color:#ff9f43>t0</span>, <span style=color:#ff9f43>main</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>csrw</span> <span style=color:#ff9f43>mepc</span>, <span style=color:#ff9f43>t0</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>mret</span>
</span></span><span style=display:flex><span>        <span style=color:#78787e># mret -&gt; Machine Return (return from exception handler)
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     1. restore MIE from MPIE
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     2. set MPIE to 1
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>        <span style=color:#78787e>#     3. jump to address stored in MEPC CSR register
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>
</span></span><span style=display:flex><span><span style=color:#57c7ff>.section</span> <span style=color:#ff9f43>.text.isr_handler</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#57c7ff>.align</span> <span style=color:#ff9f43>2</span>
</span></span><span style=display:flex><span><span style=color:#ff5c57>isr_default:</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>j</span> <span style=color:#ff9f43>isr_default</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#57c7ff>.align</span> <span style=color:#ff9f43>2</span>
</span></span><span style=display:flex><span><span style=color:#57c7ff>.option</span> <span style=color:#ff9f43>norvc</span>
</span></span><span style=display:flex><span><span style=color:#ff5c57>isr_vector:</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>start</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>0</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>isr_default</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>isr_default</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>0</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>0</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>0</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>0</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>0</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>0</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>0</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>0</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>isr_default</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>0</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>isr_default</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>0</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>isr_default</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>isr_default</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>isr_default</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>isr_default</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>isr_default</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>isr_default</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>isr_default</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>isr_default</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>isr_default</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>isr_default</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>isr_default</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>isr_default</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>isr_default</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>isr_default</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>isr_default</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>isr_default</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>isr_default</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>isr_default</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>isr_default</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>isr_default</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>isr_default</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>isr_default</span>
</span></span><span style=display:flex><span>        <span style=color:#57c7ff>.word</span>  <span style=color:#ff9f43>isr_default</span>
</span></span></code></pre></div><p><strong>Note:</strong> the <code>gp</code> (<a href=https://five-embeddev.com/quickref/global_pointer.html>global pointer</a>) initialization is a RISC-V standard but it isn&rsquo;t really needed here.</p><p>Now we have the completed code but, even though the we can compile the assembly code, we can&rsquo;t upload the raw object file because the microcontroller will not know how to interpret it. We have to create a linker script to specify the linker how to structure the resulting binary. Here&rsquo;s a simplified version of the linker script found at the <a href=https://github.com/Community-PIO-CH32V/ch32-pio-projects/blob/78f044b49b0cb201493ec6254408be459f47dcc5/baremetal-ch32v003/src/ch32v003.ld>manufacturer&rsquo;s PlatformIO repository</a>:</p><pre tabindex=0><code class=language-ld data-lang=ld>ENTRY(start);

PROVIDE(__stack_size = 256);

MEMORY {
	FLASH (rx) : ORIGIN = 0x00000000, LENGTH = 16K
	RAM (rwx)  : ORIGIN = 0x20000000, LENGTH = 2K
}

SECTIONS {
	.init : {
		. = ALIGN(4);
		PROVIDE(__start = .);
		KEEP(*(SORT_NONE(.init)));
		. = ALIGN(4);
	} &gt;FLASH AT&gt;FLASH

	.text : {
		. = ALIGN(4);
		*(.text);
		*(.text.*);
		*(.rodata);
		*(.rodata.*);
		. = ALIGN(4);
	} &gt;FLASH AT&gt;FLASH

	.data : {
		. = ALIGN(4);
		*(.data .data.*)
		PROVIDE(__data_start = .);
		. = ALIGN(8);
		/* since gp is used to access globals within +/-2KB and total RAM size is 2KB
		 * we can just set it to the base of the .data section */
		PROVIDE(__global_pointer$ = .);
		. = ALIGN(8);
		PROVIDE(__data_end = .);
	} &gt;RAM AT&gt;FLASH

	.stack ORIGIN(RAM) + LENGTH(RAM) - __stack_size : {
		PROVIDE(__heap_end = .);
		. = ALIGN(8);
		PROVIDE(__stack_start = .);
		. = . + __stack_size;
		PROVIDE(__stack_end = .);
	} &gt;RAM
}
</code></pre></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/ch32v003>ch32v003</a></li><li><a href=/tags/asm>asm</a></li></ul></nav></div></div></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/hexdhog/ rel=me title=GitHub>github</a><a class=border></a><a class=soc href=https://twitter.com/serafinebot/ rel=me title=X>twitter</a><a class=border></a></div><div class=footer-info>Built with <a href=https://gohugo.io>Hugo</a> : <a href=https://github.com/athul/archie>Archie Theme</a>
| 2025 © Serafi Nebot</div></footer></div></body></html>